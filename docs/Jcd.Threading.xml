<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Jcd.Threading</name>
    </assembly>
    <members>
        <member name="T:Jcd.Threading.IResourceLock">
            <summary>
            Provides a mechanism for establishing and releasing locks on a resource.
            </summary>
        </member>
        <member name="P:Jcd.Threading.IResourceLock.IsWaiting">
            <summary>
            Indicates if the lock is currently waiting to be acquired.
            </summary>
        </member>
        <member name="P:Jcd.Threading.IResourceLock.IsLocked">
            <summary>
            Indicates if the lock was acquired by this <see cref="T:Jcd.Threading.IResourceLock"/>
            </summary>
        </member>
        <member name="P:Jcd.Threading.IResourceLock.IsReleased">
            <summary>
            Indicates if the lock was released.
            </summary>
        </member>
        <member name="M:Jcd.Threading.IResourceLock.Wait">
            <summary>
            Locks the resource. Blocks other calls to Lock until Release is called.
            </summary>
        </member>
        <member name="M:Jcd.Threading.IResourceLock.Wait(System.Threading.CancellationToken)">
            <summary>
            Locks the resource. Blocks other calls to Lock until Release is called.
            </summary>
            <param name="token">The token to inspect for cancellation.</param>
        </member>
        <member name="M:Jcd.Threading.IResourceLock.WaitAsync">
            <summary>
            Asynchronously Locks the resource. Blocks other calls to Lock until Release is called.
            </summary>
        </member>
        <member name="M:Jcd.Threading.IResourceLock.WaitAsync(System.Threading.CancellationToken)">
            <summary>
            Asynchronously Locks the resource. Blocks other calls to Lock until Release is called.
            </summary>
            <param name="token">The token to inspect for cancellation.</param>
        </member>
        <member name="M:Jcd.Threading.IResourceLock.Release">
            <summary>
            Releases the lock on the resource.
            </summary>
        </member>
        <member name="T:Jcd.Threading.IResourceLockFactory`1">
            <summary>
            Provides a mechanism for acquiring resource locks bound to a specific instance of a synchronization primitive.
            </summary>
            <typeparam name="T">The type of the resource lock.</typeparam>
        </member>
        <member name="M:Jcd.Threading.IResourceLockFactory`1.GetResourceLock">
            <summary>
            Acquires a resource lock bound to a synchronization primitive instance.
            </summary>
            <returns>A resource lock bound to a synchronization primitive instance.</returns>
        </member>
        <member name="T:Jcd.Threading.ItemProcessor`1">
            <summary>
            Provides the ability to call a delegate on each item in an internally managed queue
            from its own background thread.
            </summary>
            <remarks>
            You must ensure all shared resources owned by the enqueued items have their access
            synchronized appropriately. This type only synchronizes access to internal data.
            </remarks>
        </member>
        <member name="M:Jcd.Threading.ItemProcessor`1.#ctor(System.Action{`0},System.Boolean,System.String,System.Boolean,System.Int32,System.Int32,System.Threading.ThreadPriority,System.Threading.ApartmentState)">
            <summary>
            Constructs a <see cref="T:Jcd.Threading.ItemProcessor`1"/>
            </summary>
            <param name="action">The action to execute on each item.</param>
            <param name="name">The name of this ItemProcessor, propagated to the underlying thread.</param>
            <param name="useBackgroundThread">Indicates if the processing thread is a background thread.</param>
            <param name="autoStart">Indicates if the thread should be automatically started.</param>
            <param name="timeToYieldInMs">Indicates the amount of time to yield pass through the main loop. Only positive values will cause a yield.</param>
            <param name="idleAfterEmptyQueueCount">the number of iterations with no items in the queue before transitioning to the idle state. Set to -1 to disable idle state detection and transition.</param>
            <param name="priority">The priority to start the processing thread at.</param>
            <param name="apartmentState">The apartment state for the underlying thread.</param>
        </member>
        <member name="M:Jcd.Threading.ItemProcessor`1.PerformWork(System.Threading.CancellationToken)">
            <summary>
            Grabs the first item in the queue and performs the user provided action on it.
            </summary>
            <param name="token">The token to inspect for cancellation.</param>
            <returns>True if there are pending items after the work is performed.</returns>
        </member>
        <member name="P:Jcd.Threading.ItemProcessor`1.Items">
            <summary>
            
            </summary>
        </member>
        <member name="P:Jcd.Threading.ItemProcessor`1.Count">
            <summary>
            The number of items in the internal queue.
            </summary>
        </member>
        <member name="P:Jcd.Threading.ItemProcessor`1.HasItems">
            <summary>
            Gets a flag indicating if there are any pending items.
            </summary>
        </member>
        <member name="M:Jcd.Threading.ItemProcessor`1.Clear">
            <summary>
            Clears all items out of the queue. USE AT YOUR OWN RISK!
            </summary>
        </member>
        <member name="M:Jcd.Threading.ItemProcessor`1.ClearAsync">
            <summary>
            Asynchronously clears all items out of the queue. USE AT YOUR OWN RISK!
            </summary>
        </member>
        <member name="M:Jcd.Threading.ItemProcessor`1.Enqueue(`0)">
            <summary>
            Enqueues an item. Control is immediately
            returned to the caller.
            </summary>
            <param name="item">The action to enqueue.</param>
        </member>
        <member name="M:Jcd.Threading.ItemProcessor`1.EnqueueAsync(`0)">
            <summary>
            Enqueues an item asynchronously. Control is immediately
            returned to the caller.
            </summary>
            <param name="item">The action to enqueue.</param>
        </member>
        <member name="M:Jcd.Threading.ItemProcessor`1.Dispose(System.Boolean)">
            <summary>
            Cleans up other disposables.
            </summary>
            <param name="disposing"></param>
        </member>
        <member name="T:Jcd.Threading.NamespaceDoc">
            <summary>
            Provides types and extension methods to assist with the creation, execution, and
            management of unstarted <see cref="T:System.Threading.Tasks.Task"/> instances.
            </summary>
        </member>
        <member name="T:Jcd.Threading.ReaderWriterLockSlimExtensions">
            <summary>
            Provides extension methods to simplify using a <see cref="T:System.Threading.ReaderWriterLockSlim"/>
            to ensure the correct pair of EnterRead+ExitRead, EnterUpgradeableRead+ExitUpgradeableRead,
            and EnterWrite+ExitWrite are called.
            </summary>
        </member>
        <member name="M:Jcd.Threading.ReaderWriterLockSlimExtensions.Lock(System.Threading.ReaderWriterLockSlim,Jcd.Threading.ReaderWriterLockSlimIntent)">
             <summary>
             Waits on a <see cref="T:System.Threading.ReaderWriterLockSlim"/> and returns a <see cref="T:Jcd.Threading.ReaderWriterLockSlimResourceLock"/> that
             calls the appropriate exit method on the lock during disposal. 
             </summary>
             <param name="rwls">The lock to acquire and release.</param>
             <param name="intent">The type of lock being acquired. By default this is a Read</param>
             <returns>the <see cref="T:Jcd.Threading.ReaderWriterLockSlimResourceLock"/> to release the resources.</returns>
             <remarks>
             <para>
             This method is intended to be used with a using block.
             There is little value in using it otherwise.
             </para>
             <code>
             // example usage.
             var rwls = new ReaderWriterLockSlim();
            
             using (rwls.Lock(ReaderWriterLockSlimIntent.Write))
             {
                // write to a critical set of values here.
                // ..
             }
             </code>
             </remarks>
        </member>
        <member name="M:Jcd.Threading.ReaderWriterLockSlimExtensions.Lock(System.Threading.ReaderWriterLockSlim,Jcd.Threading.ReaderWriterLockSlimIntent,System.Threading.CancellationToken)">
            <summary>
            Waits on a <see cref="T:System.Threading.ReaderWriterLockSlim"/> and returns a <see cref="T:Jcd.Threading.ReaderWriterLockSlimResourceLock"/> that
            calls the appropriate exit method on the lock during disposal. 
            </summary>
            <param name="rwls">The lock to acquire and release.</param>
            <param name="intent">The type of lock being acquired. By default this is a Read</param>
            <param name="token">The <see cref="T:System.Threading.CancellationToken"/> to inspect for cancellation requests</param>
            <returns>the <see cref="T:Jcd.Threading.ReaderWriterLockSlimResourceLock"/> to release the resources.</returns>
            <remarks>
            <para>
            This method is intended to be used with a using block.
            There is little value in using it otherwise.
            </para>
            <code>
            // example usage.
            var rwls = new ReaderWriterLockSlim();
            var cts = new CancellationTokenSource();
            
            using (rwls.Lock(ReaderWriterLockSlimIntent.Write, cts.Token))
            {
               // write to a critical set of values here.
               // ..
            }
            </code>
            </remarks>
        </member>
        <member name="M:Jcd.Threading.ReaderWriterLockSlimExtensions.LockAsync(System.Threading.ReaderWriterLockSlim,Jcd.Threading.ReaderWriterLockSlimIntent)">
             <summary>
             Waits on a <see cref="T:System.Threading.ReaderWriterLockSlim"/> and returns a <see cref="T:Jcd.Threading.ReaderWriterLockSlimResourceLock"/> that
             calls the appropriate exit method on the lock during disposal. 
             </summary>
             <param name="rwls">The lock to acquire and release.</param>
             <param name="intent">The type of lock being acquired. By default this is a Read</param>
             <returns>the <see cref="T:Jcd.Threading.ReaderWriterLockSlimResourceLock"/> to release the resources.</returns>
             <remarks>
             <para>
             This method is intended to be used with a using block.
             There is little value in using it otherwise.
             </para>
             <code>
             // example usage.
             var rwls = new ReaderWriterLockSlim();
            
             using (await rwls.LockAsync(ReaderWriterLockSlimIntent.Write))
             {
                // write to a critical set of values here.
                // ..
             }
             </code>
             </remarks>
        </member>
        <member name="M:Jcd.Threading.ReaderWriterLockSlimExtensions.LockAsync(System.Threading.ReaderWriterLockSlim,Jcd.Threading.ReaderWriterLockSlimIntent,System.Threading.CancellationToken)">
            <summary>
            Waits on a <see cref="T:System.Threading.ReaderWriterLockSlim"/> and returns a <see cref="T:Jcd.Threading.ReaderWriterLockSlimResourceLock"/> that
            calls the appropriate exit method on the lock during disposal. 
            </summary>
            <param name="rwls">The lock to acquire and release.</param>
            <param name="token">the <see cref="T:System.Threading.CancellationToken"/> to inspect for cancellation requests.</param>
            <param name="intent">The type of lock being acquired. By default this is a Read</param>
            <returns>the <see cref="T:Jcd.Threading.ReaderWriterLockSlimResourceLock"/> to release the resources.</returns>
            <remarks>
            <para>
            This method is intended to be used with a using block.
            There is little value in using it otherwise.
            </para>
            <code>
            // example usage.
            var rwls = new ReaderWriterLockSlim();
            var cts = new CancellationTokenSource();
            
            using (await rwls.LockAsync(ReaderWriterLockSlimIntent.Write, cts.Token))
            {
               // write to a critical set of values here.
               // ..
            }
            </code>
            </remarks>
        </member>
        <member name="M:Jcd.Threading.ReaderWriterLockSlimExtensions.GetResourceLock(System.Threading.ReaderWriterLockSlim,Jcd.Threading.ReaderWriterLockSlimIntent)">
            <summary>
            Gets a resource lock bound to the instance of a <see cref="T:System.Threading.SemaphoreSlim"/>
            </summary>
            <param name="rwls">The <see cref="T:System.Threading.SemaphoreSlim"/> to create the resource lock for.</param>
            <param name="intent">The intended purpose of the lock.</param>
            <returns>A resource lock bound to the instance of a <see cref="T:System.Threading.SemaphoreSlim"/></returns>
        </member>
        <member name="T:Jcd.Threading.ReaderWriterLockSlimIntent">
            <summary>
            Indicates the intent of a call to ReaderWriterLockSLimExtensions.Lock.
            </summary>
        </member>
        <member name="F:Jcd.Threading.ReaderWriterLockSlimIntent.Read">
            <summary>
            The lock is being used to read data.
            </summary>
        </member>
        <member name="F:Jcd.Threading.ReaderWriterLockSlimIntent.UpgradeableRead">
            <summary>
            The lock is being used to read, at first, but can be upgraded to a write.
            </summary>
        </member>
        <member name="F:Jcd.Threading.ReaderWriterLockSlimIntent.Write">
            <summary>
            The lock is being used for writing.
            </summary>
        </member>
        <member name="T:Jcd.Threading.ReaderWriterLockSlimResourceLock">
            <summary>
            Provides a mechanism for establishing and releasing locks on a <see cref="T:System.Threading.ReaderWriterLockSlim"/>.
            </summary>
            <param name="internalLock">The <see cref="T:System.Threading.ReaderWriterLockSlim"/> to lock and release. </param>
            <param name="intent">The intent of the lock (Read, UpgradeableRead, Write)</param>
            <remarks>
            <para>
            Do not share instances of this type across threads or synchronization contexts.
            Behavior can be unpredictable. These are provided and meant to be used in conjunction
            with the extension classes to create a more consistent experience when using
            synchronization primitives.
            </para> 
            </remarks>
        </member>
        <member name="M:Jcd.Threading.ReaderWriterLockSlimResourceLock.#ctor(System.Threading.ReaderWriterLockSlim,Jcd.Threading.ReaderWriterLockSlimIntent)">
            <summary>
            Provides a mechanism for establishing and releasing locks on a <see cref="T:System.Threading.ReaderWriterLockSlim"/>.
            </summary>
            <param name="internalLock">The <see cref="T:System.Threading.ReaderWriterLockSlim"/> to lock and release. </param>
            <param name="intent">The intent of the lock (Read, UpgradeableRead, Write)</param>
            <remarks>
            <para>
            Do not share instances of this type across threads or synchronization contexts.
            Behavior can be unpredictable. These are provided and meant to be used in conjunction
            with the extension classes to create a more consistent experience when using
            synchronization primitives.
            </para> 
            </remarks>
        </member>
        <member name="M:Jcd.Threading.ReaderWriterLockSlimResourceLock.Wait">
            <summary>
            Acquires a lock on the ReaderWriterLockSlim according to the intent it was created with.
            </summary>
        </member>
        <member name="M:Jcd.Threading.ReaderWriterLockSlimResourceLock.Wait(System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="M:Jcd.Threading.ReaderWriterLockSlimResourceLock.WaitAsync">
            <inheritdoc />
        </member>
        <member name="M:Jcd.Threading.ReaderWriterLockSlimResourceLock.WaitAsync(System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="M:Jcd.Threading.ReaderWriterLockSlimResourceLock.Release">
            <inheritdoc/>
        </member>
        <member name="M:Jcd.Threading.ReaderWriterLockSlimResourceLock.Dispose">
            <summary>
            Releases any locks held.
            </summary>
        </member>
        <member name="T:Jcd.Threading.ResourceLockBase">
            <summary>
            Provides a base mechanism for managing the state of <see cref="T:Jcd.Threading.IResourceLock"/> implementations.
            </summary>
        </member>
        <member name="P:Jcd.Threading.ResourceLockBase.IsWaiting">
            <inheritdoc />
        </member>
        <member name="P:Jcd.Threading.ResourceLockBase.IsLocked">
            <inheritdoc />
        </member>
        <member name="P:Jcd.Threading.ResourceLockBase.IsReleased">
            <inheritdoc />
        </member>
        <member name="M:Jcd.Threading.ResourceLockBase.Wait">
            <inheritdoc />
        </member>
        <member name="M:Jcd.Threading.ResourceLockBase.Wait(System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="M:Jcd.Threading.ResourceLockBase.WaitAsync">
            <inheritdoc />
        </member>
        <member name="M:Jcd.Threading.ResourceLockBase.WaitAsync(System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="M:Jcd.Threading.ResourceLockBase.LockAcquired">
            <summary>
            Sets IsLocked to true and returns true.
            </summary>
            <returns>true</returns>
        </member>
        <member name="M:Jcd.Threading.ResourceLockBase.Release">
            <inheritdoc/>
        </member>
        <member name="M:Jcd.Threading.ResourceLockBase.ReleaseLock">
            <summary>
            Sets flags indicated the lock has been released.
            </summary>
        </member>
        <member name="M:Jcd.Threading.ResourceLockBase.EndWait">
            <summary>
            Removes the lock from the IsWaiting state. Call at the end of your Release method.
            </summary>
        </member>
        <member name="M:Jcd.Threading.ResourceLockBase.BeginWait">
            <summary>
            Removes the lock from the IsWaiting state. 
            </summary>
        </member>
        <member name="M:Jcd.Threading.ResourceLockBase.Dispose">
            <inheritdoc />
        </member>
        <member name="T:Jcd.Threading.SemaphoreSlimExtensions">
            <summary>
            Provides extension methods to simplify using a <see cref="T:System.Threading.SemaphoreSlim"/>
            to ensure that Release is called for every Wait or WaitAsync. Useful for
            ensuring synchronized access to data for short lived operations.
            </summary>
        </member>
        <member name="M:Jcd.Threading.SemaphoreSlimExtensions.Lock(System.Threading.SemaphoreSlim)">
            <summary>
            Waits on the semaphore, and returns an <see cref="T:Jcd.Threading.SemaphoreSlimResourceLock"/> that calls Release.
            </summary>
            <param name="sem">the semaphore to use.</param>
            <returns>an <see cref="T:Jcd.Threading.SemaphoreSlimResourceLock"/> that calls Release in its Dispose method.</returns>
        </member>
        <member name="M:Jcd.Threading.SemaphoreSlimExtensions.Lock(System.Threading.SemaphoreSlim,System.Threading.CancellationToken)">
            <summary>
            Waits on the semaphore, and returns an <see cref="T:Jcd.Threading.SemaphoreSlimResourceLock"/> that calls Release.
            </summary>
            <param name="sem">the semaphore to use.</param>
            <param name="token">A cancellation token to use during the wait.</param>
            <returns>an <see cref="T:Jcd.Threading.SemaphoreSlimResourceLock"/> that calls Release in its Dispose method.</returns>
        </member>
        <member name="M:Jcd.Threading.SemaphoreSlimExtensions.LockAsync(System.Threading.SemaphoreSlim)">
            <summary>
            Asynchronously waits on the semaphore, and returns an <see cref="T:Jcd.Threading.SemaphoreSlimResourceLock"/> that calls Release.
            </summary>
            <param name="sem">the semaphore to use.</param>
            <returns>A <see cref="T:System.Threading.Tasks.Task`1"/> for an <see cref="T:Jcd.Threading.SemaphoreSlimResourceLock"/> that calls Release in its Dispose method.</returns>
        </member>
        <member name="M:Jcd.Threading.SemaphoreSlimExtensions.LockAsync(System.Threading.SemaphoreSlim,System.Threading.CancellationToken)">
            <summary>
            Asynchronously waits on the semaphore, and returns an <see cref="T:Jcd.Threading.SemaphoreSlimResourceLock"/> that calls Release.
            </summary>
            <param name="sem">the semaphore to use.</param>
            <param name="token">A cancellation token to use during the wait.</param>
            <returns>A <see cref="T:System.Threading.Tasks.Task`1"/> for an <see cref="T:Jcd.Threading.SemaphoreSlimResourceLock"/> that calls Release in its Dispose method.</returns>
        </member>
        <member name="M:Jcd.Threading.SemaphoreSlimExtensions.GetResourceLock(System.Threading.SemaphoreSlim)">
            <summary>
            Gets a resource lock bound to the instance of a <see cref="T:System.Threading.SemaphoreSlim"/>
            </summary>
            <param name="sem">The <see cref="T:System.Threading.SemaphoreSlim"/> to create the resource lock for.</param>
            <returns>A resource lock bound to the instance of a <see cref="T:System.Threading.SemaphoreSlim"/></returns>
        </member>
        <member name="T:Jcd.Threading.SemaphoreSlimResourceLock">
            <summary>
            Provides a mechanism for establishing and releasing locks on a <see cref="T:System.Threading.SemaphoreSlim"/>.
            </summary>
            <param name="internalLock">The <see cref="T:System.Threading.SemaphoreSlim"/> to lock and release. </param>
            <remarks>
            <para>
            Do not share instances of this type across threads or synchronization contexts.
            Behavior can be unpredictable. These are provided and meant to be used in conjunction
            with the extension classes to create a more consistent experience when using
            synchronization primitives.
            </para> 
            </remarks>
        </member>
        <member name="M:Jcd.Threading.SemaphoreSlimResourceLock.#ctor(System.Threading.SemaphoreSlim)">
            <summary>
            Provides a mechanism for establishing and releasing locks on a <see cref="T:System.Threading.SemaphoreSlim"/>.
            </summary>
            <param name="internalLock">The <see cref="T:System.Threading.SemaphoreSlim"/> to lock and release. </param>
            <remarks>
            <para>
            Do not share instances of this type across threads or synchronization contexts.
            Behavior can be unpredictable. These are provided and meant to be used in conjunction
            with the extension classes to create a more consistent experience when using
            synchronization primitives.
            </para> 
            </remarks>
        </member>
        <member name="M:Jcd.Threading.SemaphoreSlimResourceLock.Wait">
            <inheritdoc/>
        </member>
        <member name="M:Jcd.Threading.SemaphoreSlimResourceLock.Wait(System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:Jcd.Threading.SemaphoreSlimResourceLock.WaitAsync">
            <inheritdoc/>
        </member>
        <member name="M:Jcd.Threading.SemaphoreSlimResourceLock.WaitAsync(System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:Jcd.Threading.SemaphoreSlimResourceLock.Release">
            <inheritdoc/>
        </member>
        <member name="M:Jcd.Threading.SemaphoreSlimResourceLock.Dispose">
            <summary>
            Releases any locks held.
            </summary>
        </member>
        <member name="T:Jcd.Threading.SpinLockExtensions">
            <summary>
            Provides extension methods to aid in working with SpinLocks
            </summary>
        </member>
        <member name="M:Jcd.Threading.SpinLockExtensions.Lock(System.Threading.SpinLock@,System.Action,System.Boolean)">
            <summary>
            Acquires exclusive access to the spinLock and executes the provided action.
            </summary>
            <param name="spinLock">The <see cref="T:System.Threading.SpinLock"/> to use for locking.</param>
            <param name="action">The action to perform</param>
            <param name="useMemoryBarrierOnExit">Passed to `Exit` when releasing the lock.</param>
        </member>
        <member name="M:Jcd.Threading.SpinLockExtensions.LockAsync(System.Threading.SpinLock@,System.Action,System.Boolean)">
            <summary>
            Acquires exclusive access to the spinLock and executes the provided action.
            </summary>
            <param name="spinLock">The <see cref="T:System.Threading.SpinLock"/> to use for locking.</param>
            <param name="action">The action to perform</param>
            <param name="useMemoryBarrierOnExit">Passed to `Exit` when releasing the lock.</param>
        </member>
        <member name="M:Jcd.Threading.SpinLockExtensions.Lock(System.Threading.SpinLock@)">
            <summary>
            Waits on the semaphore, and returns an <see cref="T:Jcd.Threading.SpinLockResourceLock"/> that calls Release.
            </summary>
            <param name="sem">the semaphore to use.</param>
            <returns>an <see cref="T:Jcd.Threading.SpinLockResourceLock"/> that calls Release in its Dispose method.</returns>
        </member>
        <member name="M:Jcd.Threading.SpinLockExtensions.Lock(System.Threading.SpinLock@,System.Threading.CancellationToken)">
            <summary>
            Waits on the semaphore, and returns an <see cref="T:Jcd.Threading.SpinLockResourceLock"/> that calls Release.
            </summary>
            <param name="sem">the semaphore to use.</param>
            <param name="token">A cancellation token to use during the wait.</param>
            <returns>an <see cref="T:Jcd.Threading.SpinLockResourceLock"/> that calls Release in its Dispose method.</returns>
        </member>
        <member name="M:Jcd.Threading.SpinLockExtensions.GetResourceLock(System.Threading.SpinLock@)">
            <summary>
            Gets a resource lock bound to the instance of a <see cref="T:System.Threading.SpinLock"/>
            </summary>
            <param name="sem">The <see cref="T:System.Threading.SpinLock"/> to create the resource lock for.</param>
            <returns>A resource lock bound to the instance of a <see cref="T:System.Threading.SpinLock"/></returns>
        </member>
        <member name="T:Jcd.Threading.SpinLockResourceLock">
            <summary>
            Acquires a lock on the <see cref="T:System.Threading.SpinLock"/> it was created with.
            </summary>
        </member>
        <member name="M:Jcd.Threading.SpinLockResourceLock.#ctor(System.Threading.SpinLock@)">
            <summary>
            Creates an instance of <see cref="T:Jcd.Threading.SpinLockResourceLock"/> bound to a specific <see cref="T:System.Threading.SpinLock"/>
            </summary>
            <param name="internalLock">The <see cref="T:System.Threading.SpinLock"/> to bind to.</param>
        </member>
        <member name="P:Jcd.Threading.SpinLockResourceLock.IsWaiting">
            <summary>
            Indicates if the lock is currently waiting to acquire the resource.
            </summary>
        </member>
        <member name="P:Jcd.Threading.SpinLockResourceLock.IsLocked">
            <summary>
            Indicates if the lock was acquired by this <see cref="T:Jcd.Threading.SpinLockResourceLock"/>
            </summary>
        </member>
        <member name="P:Jcd.Threading.SpinLockResourceLock.IsReleased">
            <summary>
            Indicates if the lock was released.
            </summary>
        </member>
        <member name="M:Jcd.Threading.SpinLockResourceLock.Wait">
            <summary>
            Locks the resource. Blocks other calls to Lock until Release is called.
            </summary>
        </member>
        <member name="M:Jcd.Threading.SpinLockResourceLock.Wait(System.Threading.CancellationToken)">
            <summary>
            Locks the resource. Blocks other calls to Lock until Release is called.
            </summary>
            <param name="token">The token to inspect for cancellation.</param>
        </member>
        <member name="M:Jcd.Threading.SpinLockResourceLock.WaitAsync">
            <summary>
            Asynchronously Locks the resource. Blocks other calls to Lock until Release is called.
            </summary>
        </member>
        <member name="M:Jcd.Threading.SpinLockResourceLock.WaitAsync(System.Threading.CancellationToken)">
            <summary>
            Asynchronously Locks the resource. Blocks other calls to Lock until Release is called.
            </summary>
            <param name="token">The token to inspect for cancellation.</param>
        </member>
        <member name="M:Jcd.Threading.SpinLockResourceLock.LockAcquired">
            <summary>
            Sets IsLocked to true and returns true.
            </summary>
            <returns>true</returns>
        </member>
        <member name="M:Jcd.Threading.SpinLockResourceLock.ReleaseLock">
            <summary>
            Sets flags indicated the lock has been released.
            </summary>
        </member>
        <member name="M:Jcd.Threading.SpinLockResourceLock.EndWait">
            <summary>
            Removes the lock from the IsWaiting state. Call at the end of your Release method.
            </summary>
        </member>
        <member name="M:Jcd.Threading.SpinLockResourceLock.BeginWait">
            <summary>
            Removes the lock from the IsWaiting state. 
            </summary>
        </member>
        <member name="M:Jcd.Threading.SpinLockResourceLock.Release">
            <summary>
            Releases the lock on the resource.
            </summary>
        </member>
        <member name="M:Jcd.Threading.SpinLockResourceLock.Dispose">
            <summary>
            Releases the lock on the resource.
            </summary>
        </member>
        <member name="T:Jcd.Threading.SynchronizedValues.ReaderWriterLockSlimValue`1">
            <summary>
            Provides a simple async-safe and thread-safe method of setting, getting, acting on,
            and altering values shared among tasks and threads.
            </summary>
            <param name="val">The value to initialize this to</param>
            <typeparam name="T">The data type to synchronize access to.</typeparam>
            <remarks>
            <para>
            While this provides a method of easily ensuring any one shared value is appropriately
            locked during setting or getting, you still need to thoroughly understand your
            use case. For example, having two <see cref="T:Jcd.Threading.SynchronizedValues.ReaderWriterLockSlimValue`1"/> instances accessed
            by two different threads, in rapid succession, in different orders can cause
            potentially unexpected results.
            </para>
            <para>
            In cases where the pair/tuple must be consistent at all times across all accesses,
            consider creating a struct containing the necessary fields/properties and wrapping
            that in a <see cref="T:Jcd.Threading.SynchronizedValues.ReaderWriterLockSlimValue`1"/> instead of each individual field/property.
            </para>
            <para>
            As well this implementation uses <see cref="T:System.Threading.SemaphoreSlim"/> and requires Dispose to be
            called. Either implement <see cref="T:System.IDisposable"/> or call it directly at the appropriate
            time. See the documentation for <see cref="M:Jcd.Threading.SynchronizedValues.ReaderWriterLockSlimValue`1.ChangeValue(System.Func{`0,`0})"/>, <see cref="M:Jcd.Threading.SynchronizedValues.ReaderWriterLockSlimValue`1.ChangeValueAsync(System.Func{`0,System.Threading.Tasks.Task{`0}})"/>,
            for recursive reentrancy considerations. <i>(i.e. don't try it!)</i>
            </para>
            </remarks>
        </member>
        <member name="M:Jcd.Threading.SynchronizedValues.ReaderWriterLockSlimValue`1.#ctor(`0)">
            <summary>
            Provides a simple async-safe and thread-safe method of setting, getting, acting on,
            and altering values shared among tasks and threads.
            </summary>
            <param name="val">The value to initialize this to</param>
            <typeparam name="T">The data type to synchronize access to.</typeparam>
            <remarks>
            <para>
            While this provides a method of easily ensuring any one shared value is appropriately
            locked during setting or getting, you still need to thoroughly understand your
            use case. For example, having two <see cref="T:Jcd.Threading.SynchronizedValues.ReaderWriterLockSlimValue`1"/> instances accessed
            by two different threads, in rapid succession, in different orders can cause
            potentially unexpected results.
            </para>
            <para>
            In cases where the pair/tuple must be consistent at all times across all accesses,
            consider creating a struct containing the necessary fields/properties and wrapping
            that in a <see cref="T:Jcd.Threading.SynchronizedValues.ReaderWriterLockSlimValue`1"/> instead of each individual field/property.
            </para>
            <para>
            As well this implementation uses <see cref="T:System.Threading.SemaphoreSlim"/> and requires Dispose to be
            called. Either implement <see cref="T:System.IDisposable"/> or call it directly at the appropriate
            time. See the documentation for <see cref="M:Jcd.Threading.SynchronizedValues.ReaderWriterLockSlimValue`1.ChangeValue(System.Func{`0,`0})"/>, <see cref="M:Jcd.Threading.SynchronizedValues.ReaderWriterLockSlimValue`1.ChangeValueAsync(System.Func{`0,System.Threading.Tasks.Task{`0}})"/>,
            for recursive reentrancy considerations. <i>(i.e. don't try it!)</i>
            </para>
            </remarks>
        </member>
        <member name="M:Jcd.Threading.SynchronizedValues.ReaderWriterLockSlimValue`1.Dispose">
            <inheritdoc />
        </member>
        <member name="P:Jcd.Threading.SynchronizedValues.ReaderWriterLockSlimValue`1.Value">
             <summary>
             Get or sets the synchronized value.
             </summary>
             <example>
             <code>
             var sv = new ReaderWriterLockSlimValue&lt;int&gt;(15);
             
             // get the value
             var theValue = sv.Value;
            
             // set the value
             sv.Value = theValue + 10;
             
             </code>
             </example>
        </member>
        <member name="M:Jcd.Threading.SynchronizedValues.ReaderWriterLockSlimValue`1.GetValue">
            <summary>
            Retrieves the current value. If another thread edits the value, moment later a subsequent
            call will yield a different result. 
            </summary>
            <returns>The current value as of establishing the lock.</returns>
            <example>
            <code>
            var sv = new ReaderWriterLockSlimValue&lt;int&gt;(15);
            
            // get the value
            var result = sv.GetValue(20);
            
            </code>
            </example>
        </member>
        <member name="M:Jcd.Threading.SynchronizedValues.ReaderWriterLockSlimValue`1.GetValueAsync">
            <summary>
            Gets the value in an async friendly manner.
            </summary>
            <returns>A <see cref="T:System.Threading.Tasks.Task`1"/> containing the retrieved value.</returns>
            <example>
            <code>
            var sv = new ReaderWriterLockSlimValue&lt;int&gt;(15);
            
            // get the value
            var result = await sv.GetValueAsync(20);
            
            </code>
            </example>
        </member>
        <member name="M:Jcd.Threading.SynchronizedValues.ReaderWriterLockSlimValue`1.SetValue(`0)">
            <summary>
            Sets the current value to the provided value.
            </summary>
            <param name="value">The provided value.</param>
            <returns>The provided value.</returns>
            <example>
            <code>
            var sv = new ReaderWriterLockSlimValue&lt;int&gt;();
            
            // set the value to 10.
            var result = sv.SetValue(10);
            
            // set the value to 20.
            result = sv.SetValue(20);
            
            </code>
            </example>
        </member>
        <member name="M:Jcd.Threading.SynchronizedValues.ReaderWriterLockSlimValue`1.SetValueAsync(`0)">
            <summary>
            Sets the current value to the provided value.
            </summary>
            <param name="value">The provided value.</param>
            <returns>A <see cref="T:System.Threading.Tasks.Task`1"/> containing the provided value.</returns>
            <example>
            <code>
            var sv = new ReaderWriterLockSlimValue&lt;int&gt;();
            
            // set the value to 10.
            var result = await sv.SetValueAsync(10);
            
            // set the value to 20.
            result = await sv.SetValueAsync(20);
            
            </code>
            </example>
        </member>
        <member name="M:Jcd.Threading.SynchronizedValues.ReaderWriterLockSlimValue`1.ChangeValue(System.Func{`0,`0})">
             <summary>
             Calls the provided function, passing in the current value, and assigns the result
             of the function call, to the current value. <b>This is not recursively reentrant.
             see remarks for details.</b>
             </summary>
             <param name="func">
             A function to call which receives the current value, modifies it, and returns the
             modified result.
             </param>
             <returns>The modified value.</returns>
             <example>
             Standard usage: pass in a function to manipulate the current value.
             <code>
             var sv = new ReaderWriterLockSlimValue&lt;int&gt;();
             
             // increment the value by one.
             var changedValue = sv.Do(x => x + 1);
             
             // increment the value by two.
             changedValue = sv.Do(x => x + 2);
             
             </code>
             </example>
             <remarks>
             <para>
             <b>WARNING:</b>This is <b>not</b> a recursively reentrant method. Never write code like
             the following.
             </para>
             <code>
             var sv=new ReaderWriterLockSlimValue&lt;int&gt;(10);
            
             // deadlock yourself in a single line of code!
             var changedValue = sv.Do(x=>sv.Value+10);
             </code>
             </remarks>
        </member>
        <member name="M:Jcd.Threading.SynchronizedValues.ReaderWriterLockSlimValue`1.ChangeValueAsync(System.Func{`0,System.Threading.Tasks.Task{`0}})">
             <summary>
             Calls the provided function, passing in the current value, and assigns the result
             of the function call, to the current value. <b>This is not recursively reentrant.
             see remarks for details.</b>
             </summary>
             <param name="func">The function to call.</param>
             <returns>A <see cref="T:System.Threading.Tasks.Task`1"/> containing the modified value.</returns>
             <example>
             Standard usage: pass in a function to manipulate the current value.
             <code>
             var sv = new ReaderWriterLockSlimValue&lt;int&gt;();
             
             // increment the value by one.
             var changedValue = await sv.ChangeValueAsync(x => x + 1);
             
             // increment the value by two.
             changedValue = await sv.ChangeValueAsync(x => x + 2);
             
             // Perform some operation that requires the value to remain unchanged during the operation.
             var sameValue = await sv.ChangeValueAsync(x => { DoSomething(x); return x;});
             </code>
             </example>
             <remarks>
             <para>
             <b>WARNING:</b>This is <b>not</b> a recursively reentrant method. Never write code like
             the following.
             </para>
             <code>
             var sv=new ReaderWriterLockSlimValue&lt;int&gt;(10);
            
             // deadlock yourself in a single line of code!
             var changedValue = await sv.ChangeValueAsync(x=>sv.Value+10);
             </code>
             </remarks>
        </member>
        <member name="T:Jcd.Threading.SynchronizedValues.SemaphoreSlimValue`1">
            <summary>
            A value wrapper with a <see cref="T:System.Threading.SemaphoreSlim"/> to block access during reads and writes.
            This results in single writer or single reader access to the data.  
            </summary>
            <typeparam name="T">The data type to synchronize access to.</typeparam>
        </member>
        <member name="M:Jcd.Threading.SynchronizedValues.SemaphoreSlimValue`1.#ctor(`0)">
            <summary>
            Constructs an instance of <see cref="T:Jcd.Threading.SynchronizedValues.SemaphoreSlimValue`1"/>
            </summary>
            <param name="value">the initial value to store></param>
        </member>
        <member name="M:Jcd.Threading.SynchronizedValues.SemaphoreSlimValue`1.Dispose">
            <inheritdoc />
        </member>
        <member name="P:Jcd.Threading.SynchronizedValues.SemaphoreSlimValue`1.Value">
            <summary>
            The value protected by the mutex.
            </summary>
        </member>
        <member name="M:Jcd.Threading.SynchronizedValues.SemaphoreSlimValue`1.GetValue">
            <summary>
            Retrieves the current value. If another thread edits the value, moment later a subsequent
            call will yield a different result. 
            </summary>
            <returns>The current value as of establishing the lock.</returns>
            <example>
            <code>
            var sv = new SemaphoreSlimValue&lt;int&gt;(15);
            
            // get the value
            var result = sv.GetValue(20);
            
            </code>
            </example>
        </member>
        <member name="M:Jcd.Threading.SynchronizedValues.SemaphoreSlimValue`1.GetValueAsync">
            <summary>
            Gets the value in an async friendly manner.
            </summary>
            <returns>A <see cref="T:System.Threading.Tasks.Task`1"/> containing the retrieved value.</returns>
            <example>
            <code>
            var sv = new SemaphoreSlimValue&lt;int&gt;(15);
            
            // get the value
            var result = await sv.GetValueAsync(20);
            
            </code>
            </example>
        </member>
        <member name="M:Jcd.Threading.SynchronizedValues.SemaphoreSlimValue`1.SetValue(`0)">
            <summary>
            Sets the current value to the provided value.
            </summary>
            <param name="value">The provided value.</param>
            <returns>The provided value.</returns>
            <example>
            <code>
            var sv = new SemaphoreSlimValue&lt;int&gt;();
            
            // set the value to 10.
            var result = sv.SetValue(10);
            
            // set the value to 20.
            setValue = sv.SetValue(20);
            
            </code>
            </example>
        </member>
        <member name="M:Jcd.Threading.SynchronizedValues.SemaphoreSlimValue`1.SetValueAsync(`0)">
            <summary>
            Sets the current value to the provided value.
            </summary>
            <param name="value">The provided value.</param>
            <returns>A <see cref="T:System.Threading.Tasks.Task`1"/> containing the provided value.</returns>
            <example>
            <code>
            var sv = new SemaphoreSlimValue&lt;int&gt;();
            
            // set the value to 10.
            var result = await sv.SetValueAsync(10);
            
            // set the value to 20.
            result = await sv.SetValueAsync(20);
            
            </code>
            </example>
        </member>
        <member name="M:Jcd.Threading.SynchronizedValues.SemaphoreSlimValue`1.ChangeValue(System.Func{`0,`0})">
             <summary>
             Calls the provided function, passing in the current value, and assigns the result
             of the function call, to the current value. <b>This is not recursively reentrant.
             see remarks for details.</b>
             </summary>
             <param name="func">
             A function to call which receives the current value, modifies it, and returns the
             modified result.
             </param>
             <returns>The modified value.</returns>
             <example>
             Standard usage: pass in a function to manipulate the current value.
             <code>
             var sv = new SemaphoreSlimValue&lt;int&gt;();
             
             // increment the value by one.
             var changedValue = sv.ChangeValue(x => x + 1);
             
             // increment the value by two.
             changedValue = sv.ChangeValue(x => x + 2);
             
             </code>
             </example>
             <remarks>
             <para>
             <b>WARNING:</b>This is <b>not</b> a recursively reentrant method. Never write code like
             the following.
             </para>
             <code>
             var sv=new SemaphoreSlimValue&lt;int&gt;(10);
            
             // deadlock yourself in a single line of code!
             var changedValue = sv.ChangeValue(x=>sv.Value+10);
             </code>
             </remarks>
        </member>
        <member name="M:Jcd.Threading.SynchronizedValues.SemaphoreSlimValue`1.ChangeValueAsync(System.Func{`0,System.Threading.Tasks.Task{`0}})">
             <summary>
             Calls the provided function, passing in the current value, and assigns the result
             of the function call, to the current value. <b>This is not recursively reentrant.
             see remarks for details.</b>
             </summary>
             <param name="func">The function to call.</param>
             <returns>A <see cref="T:System.Threading.Tasks.Task`1"/> containing the modified value.</returns>
             <example>
             Standard usage: pass in a function to manipulate the current value.
             <code>
             var sv = new SemaphoreSlimValue&lt;int&gt;();
             
             // increment the value by one.
             var changedValue = await sv.ChangeValueAsync(x => x + 1);
             
             // increment the value by two.
             changedValue = await sv.ChangeValueAsync(x => x + 2);
             
             // Perform some operation that requires the value to remain unchanged during the operation.
             var sameValue = await sv.ChangeValueAsync(x => { DoSomething(x); return x;});
             </code>
             </example>
             <remarks>
             <para>
             <b>WARNING:</b>This is <b>not</b> a recursively reentrant method. Never write code like
             the following.
             </para>
             <code>
             var sv=new SemaphoreSlimValue&lt;int&gt;(10);
            
             // deadlock yourself in a single line of code!
             var changedValue = await sv.ChangeValueAsync(x=>sv.Value+10);
             </code>
             </remarks>
        </member>
        <member name="T:Jcd.Threading.SynchronizedValues.SpinLockValue`1">
            <summary>
            Provides synchronization to an underlying value through a <see cref="T:System.Threading.SpinLock"/>.
            </summary>
            <typeparam name="T">The type of the data being stored.</typeparam>
        </member>
        <member name="M:Jcd.Threading.SynchronizedValues.SpinLockValue`1.#ctor(`0,System.Boolean,System.Boolean)">
            <summary>
            Creates an instance of a <see cref="T:Jcd.Threading.SynchronizedValues.SpinLockValue`1"/>
            </summary>
            <param name="initialVal">The initial value</param>
            <param name="useMemoryBarrier">Indicates if the call to Exit should use a memory barrier to notify other threads the lock has been freed(much slower!).</param>
            <param name="useThreadTracking">Indicates if the <see cref="T:System.Threading.SpinLock"/> uses thread tracking.</param>
        </member>
        <member name="P:Jcd.Threading.SynchronizedValues.SpinLockValue`1.Value">
            <summary>
            Sets or gets the value. This will block.
            </summary>
        </member>
        <member name="M:Jcd.Threading.SynchronizedValues.SpinLockValue`1.GetValue">
            <summary>
            Retrieves the current value. If another thread edits the value, moment later a subsequent
            call will yield a different result. 
            </summary>
            <returns>The current value as of establishing the lock.</returns>
            <example>
            <code>
            var sv = new SpinLockValue&lt;int&gt;(15);
            
            // get the value
            setValue = sv.GetValue(20);
            
            </code>
            </example>
        </member>
        <member name="M:Jcd.Threading.SynchronizedValues.SpinLockValue`1.GetValueAsync">
            <summary>
            Gets the value in an async friendly manner.
            </summary>
            <returns>A <see cref="T:System.Threading.Tasks.Task`1"/> containing the retrieved value.</returns>
            <example>
            <code>
            var sv = new SpinLockValue&lt;int&gt;(15);
            
            // get the value
            var result = await sv.GetValueAsync(20);
            
            </code>
            </example>
        </member>
        <member name="M:Jcd.Threading.SynchronizedValues.SpinLockValue`1.SetValue(`0)">
            <summary>
            Sets the current value to the provided value.
            </summary>
            <param name="value">The provided value.</param>
            <returns>The provided value.</returns>
            <example>
            <code>
            var sv = new SpinLockValue&lt;int&gt;();
            
            // set the value to 10.
            var result = sv.SetValue(10);
            
            // set the value to 20.
            setValue = sv.SetValue(20);
            
            </code>
            </example>
        </member>
        <member name="M:Jcd.Threading.SynchronizedValues.SpinLockValue`1.SetValueAsync(`0)">
            <summary>
            Sets the current value to the provided value.
            </summary>
            <param name="value">The provided value.</param>
            <returns>A <see cref="T:System.Threading.Tasks.Task`1"/> containing the provided value.</returns>
            <example>
            <code>
            var sv = new SpinLockValue&lt;int&gt;();
            
            // set the value to 10.
            var result = await sv.SetValueAsync(10);
            
            // set the value to 20.
            result = await sv.SetValueAsync(20);
            
            </code>
            </example>
        </member>
        <member name="M:Jcd.Threading.SynchronizedValues.SpinLockValue`1.ChangeValue(System.Func{`0,`0})">
             <summary>
             Calls the provided function, passing in the current value, and assigns the result
             of the function call, to the current value. <b>This is not recursively reentrant.
             see remarks for details.</b>
             </summary>
             <param name="func">
             A function to call which receives the current value, modifies it, and returns the
             modified result.
             </param>
             <returns>The modified value.</returns>
             <example>
             Standard usage: pass in a function to manipulate the current value.
             <code>
             var sv = new SpinLockValue&lt;int&gt;();
             
             // increment the value by one.
             var changedValue = sv.ChangeValue(x => x + 1);
             
             // increment the value by two.
             changedValue = sv.ChangeValue(x => x + 2);
             
             </code>
             </example>
             <remarks>
             <para>
             <b>WARNING:</b>This is <b>not</b> a recursively reentrant method. Never write code like
             the following.
             </para>
             <code>
             var sv=new SpinLockValue&lt;int&gt;(10);
            
             // deadlock yourself in a single line of code!
             var changedValue = sv.ChangeValue(x=>sv.Value+10);
             </code>
             </remarks>
        </member>
        <member name="M:Jcd.Threading.SynchronizedValues.SpinLockValue`1.ChangeValueAsync(System.Func{`0,System.Threading.Tasks.Task{`0}})">
             <summary>
             Calls the provided function, passing in the current value, and assigns the result
             of the function call, to the current value. <b>This is not recursively reentrant.
             see remarks for details.</b>
             </summary>
             <param name="func">The function to call.</param>
             <returns>A <see cref="T:System.Threading.Tasks.Task`1"/> containing the modified value.</returns>
             <example>
             Standard usage: pass in a function to manipulate the current value.
             <code>
             var sv = new SpinLockValue&lt;int&gt;();
             
             // increment the value by one.
             var changedValue = await sv.ChangeValueAsync(x => x + 1);
             
             // increment the value by two.
             changedValue = await sv.ChangeValueAsync(x => x + 2);
             
             // Perform some operation that requires the value to remain unchanged during the operation.
             var sameValue = await sv.ChangeValueAsync(x => { DoSomething(x); return x;});
             </code>
             </example>
             <remarks>
             <para>
             <b>WARNING:</b>This is <b>not</b> a recursively reentrant method. Never write code like
             the following.
             </para>
             <code>
             var sv=new SpinLockValue&lt;int&gt;(10);
            
             // deadlock yourself in a single line of code!
             var changedValue = await sv.ChangeValueAsync(x=>sv.Value+10);
             </code>
             </remarks>
        </member>
        <member name="T:Jcd.Threading.SynchronizedValues.TicketLockValue`1">
            <summary>
            A value wrapper for a <see cref="T:Jcd.Threading.TicketLock"/> to block access during reads
            and writes. It guarantees in order execution of locks.
            </summary>
            <typeparam name="T">The data type to synchronize access to.</typeparam>
        </member>
        <member name="M:Jcd.Threading.SynchronizedValues.TicketLockValue`1.#ctor(`0)">
            <summary>
            Constructs an instance of <see cref="T:Jcd.Threading.SynchronizedValues.TicketLockValue`1"/>
            </summary>
            <param name="initialValue">the initial value to store></param>
        </member>
        <member name="P:Jcd.Threading.SynchronizedValues.TicketLockValue`1.Value">
            <summary>
            The synchronized value.
            </summary>
        </member>
        <member name="M:Jcd.Threading.SynchronizedValues.TicketLockValue`1.GetValue">
            <summary>
            Retrieves the current value. If another thread edits the value, moment later a subsequent
            call will yield a different result. 
            </summary>
            <returns>The current value as of establishing the lock.</returns>
            <example>
            <code>
            var sv = new TicketLockedValue&lt;int&gt;(15);
            
            // get the value
            setValue = sv.GetValue(20);
            
            </code>
            </example>
        </member>
        <member name="M:Jcd.Threading.SynchronizedValues.TicketLockValue`1.GetValueAsync">
            <summary>
            Gets the value in an async friendly manner.
            </summary>
            <returns>A <see cref="T:System.Threading.Tasks.Task"/> containing the retrieved value.</returns>
            <example>
            <code>
            var sv = new TicketLockedValue&lt;int&gt;(15);
            
            // get the value
            var result = await sv.GetValueAsync(20);
            
            </code>
            </example>
        </member>
        <member name="M:Jcd.Threading.SynchronizedValues.TicketLockValue`1.SetValue(`0)">
            <summary>
            Sets the current value to the provided value.
            </summary>
            <param name="value">The provided value.</param>
            <returns>The provided value.</returns>
            <example>
            <code>
            var sv = new TicketLockValue&lt;int&gt;();
            
            // set the value to 10.
            var result = sv.SetValue(10);
            
            // set the value to 20.
            result = sv.SetValue(20);
            
            </code>
            </example>
        </member>
        <member name="M:Jcd.Threading.SynchronizedValues.TicketLockValue`1.SetValueAsync(`0)">
            <summary>
            Sets the current value to the provided value.
            </summary>
            <param name="value">The provided value.</param>
            <returns>A <see cref="T:System.Threading.Tasks.Task`1"/> containing the provided value.</returns>
            <example>
            <code>
            var sv = new TicketLockedValue&lt;int&gt;();
            
            // set the value to 10.
            var result = await sv.SetValueAsync(10);
            
            // set the value to 20.
            result = await sv.SetValueAsync(20);
            
            </code>
            </example>
        </member>
        <member name="M:Jcd.Threading.SynchronizedValues.TicketLockValue`1.ChangeValue(System.Func{`0,`0})">
             <summary>
             Calls the provided function, passing in the current value, and assigns the result
             of the function call, to the current value. <b>This is not recursively reentrant.
             see remarks for details.</b>
             </summary>
             <param name="func">
             A function to call which receives the current value, modifies it, and returns the
             modified result.
             </param>
             <returns>The modified value.</returns>
             <example>
             Standard usage: pass in a function to manipulate the current value.
             <code>
             var sv = new TicketLockValue&lt;int&gt;();
             
             // increment the value by one.
             var changedValue = sv.Do(x => x + 1);
             
             // increment the value by two.
             changedValue = sv.Do(x => x + 2);
             
             </code>
             </example>
             <remarks>
             <para>
             <b>WARNING:</b>This is <b>not</b> a recursively reentrant method. Never write code like
             the following.
             </para>
             <code>
             var sv=new TicketLockValue&lt;int&gt;(10);
            
             // deadlock yourself in a single line of code!
             var changedValue = sv.ChangeValue(x=>sv.Value+10);
             </code>
             </remarks>
        </member>
        <member name="M:Jcd.Threading.SynchronizedValues.TicketLockValue`1.ChangeValueAsync(System.Func{`0,System.Threading.Tasks.Task{`0}})">
             <summary>
             Calls the provided function, passing in the current value, and assigns the result
             of the function call, to the current value. <b>This is not recursively reentrant.
             see remarks for details.</b>
             </summary>
             <param name="func">The function to call.</param>
             <returns>A <see cref="T:System.Threading.Tasks.Task`1"/> containing the modified value.</returns>
             <example>
             Standard usage: pass in a function to manipulate the current value.
             <code>
             var sv = new TicketLockValue&lt;int&gt;();
             
             // increment the value by one.
             var changedValue = await sv.ChangeValueAsync(x => x + 1);
             
             // increment the value by two.
             changedValue = await sv.ChangeValueAsync(x => x + 2);
             
             // Perform some operation that requires the value to remain unchanged during the operation.
             var sameValue = await sv.ChangeValueAsync(x => { DoSomething(x); return x;});
             </code>
             </example>
             <remarks>
             <para>
             <b>WARNING:</b>This is <b>not</b> a recursively reentrant method. Never write code like
             the following.
             </para>
             <code>
             var sv=new TicketLockValue&lt;int&gt;(10);
            
             // deadlock yourself in a single line of code!
             var changedValue = await sv.ChangeValueAsync(x=>sv.Value+10);
             </code>
             </remarks>
        </member>
        <member name="T:Jcd.Threading.Tasks.CurrentTaskSchedulerRunner">
            <summary>
            A static class that schedules tasks on the current <see cref="T:System.Threading.Tasks.TaskScheduler"/> or
            a user provided <see cref="T:System.Threading.Tasks.TaskScheduler"/> if null is passed in or none is specified.
            </summary>
        </member>
        <member name="P:Jcd.Threading.Tasks.CurrentTaskSchedulerRunner.Scheduler">
            <summary>
            The current <see cref="T:System.Threading.Tasks.TaskScheduler"/>
            </summary>
        </member>
        <member name="M:Jcd.Threading.Tasks.CurrentTaskSchedulerRunner.Run(System.Action,System.Threading.Tasks.TaskScheduler)">
            <summary>
            Schedules work with the current or user provided <see cref="T:System.Threading.Tasks.TaskScheduler"/>
            </summary>
            <param name="action">the action to run</param>
            <param name="scheduler">The scheduler to use, pass null to use the the current one. </param>
            <returns></returns>
        </member>
        <member name="M:Jcd.Threading.Tasks.CurrentTaskSchedulerRunner.Run(System.Action,System.Threading.CancellationToken,System.Threading.Tasks.TaskScheduler)">
            <summary>
            Schedules work with the current or user provided <see cref="T:System.Threading.Tasks.TaskScheduler"/>
            </summary>
            <param name="action">the action to execute.</param>
            <param name="cancellationToken">the token to check for cancellation.</param>
            <param name="scheduler">The optional scheduler to execute the action with.</param>
            <returns>The <see cref="T:System.Threading.Tasks.Task"/> representing the result of the execution.</returns>
        </member>
        <member name="M:Jcd.Threading.Tasks.CurrentTaskSchedulerRunner.Run(System.Func{System.Threading.Tasks.Task},System.Threading.Tasks.TaskScheduler)">
            <summary>
            Schedules work with the current or user provided <see cref="T:System.Threading.Tasks.TaskScheduler"/>
            </summary>
            <param name="function">the function to execute.</param>
            <param name="scheduler">The optional scheduler to execute the function with.</param>
            <returns>The <see cref="T:System.Threading.Tasks.Task"/> representing the result of the execution.</returns>
        </member>
        <member name="M:Jcd.Threading.Tasks.CurrentTaskSchedulerRunner.Run(System.Func{System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Threading.Tasks.TaskScheduler)">
            <summary>
            Schedules work with the current or user provided <see cref="T:System.Threading.Tasks.TaskScheduler"/>
            </summary>
            <param name="function">the function to execute.</param>
            <param name="cancellationToken">the token to check for cancellation.</param>
            <param name="scheduler">The optional scheduler to execute the function with.</param>
            <returns>The <see cref="T:System.Threading.Tasks.Task"/> representing the result of the execution.</returns>
        </member>
        <member name="M:Jcd.Threading.Tasks.CurrentTaskSchedulerRunner.Run``1(System.Func{``0},System.Threading.Tasks.TaskScheduler)">
            <summary>
            Schedules work with the current or user provided <see cref="T:System.Threading.Tasks.TaskScheduler"/>
            </summary>
            <param name="function">the function to execute.</param>
            <param name="scheduler">The optional scheduler to execute the function with.</param>
            <returns>The <see cref="T:System.Threading.Tasks.Task"/> representing the result of the execution.</returns>
        </member>
        <member name="M:Jcd.Threading.Tasks.CurrentTaskSchedulerRunner.Run``1(System.Func{``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskScheduler)">
            <summary>
            Schedules work with the current or user provided <see cref="T:System.Threading.Tasks.TaskScheduler"/>
            </summary>
            <param name="function">the function to execute.</param>
            <param name="cancellationToken">the token to check for cancellation.</param>
            <param name="scheduler">The optional scheduler to execute the function with.</param>
            <returns>The <see cref="T:System.Threading.Tasks.Task"/> representing the result of the execution.</returns>
        </member>
        <member name="M:Jcd.Threading.Tasks.CurrentTaskSchedulerRunner.Run``1(System.Func{System.Threading.Tasks.Task{``0}},System.Threading.Tasks.TaskScheduler)">
            <summary>
            Schedules work with the current or user provided <see cref="T:System.Threading.Tasks.TaskScheduler"/>
            </summary>
            <param name="function">the function to execute.</param>
            <param name="scheduler">The optional scheduler to execute the function with.</param>
            <returns>The <see cref="T:System.Threading.Tasks.Task"/> representing the result of the execution.</returns>
        </member>
        <member name="M:Jcd.Threading.Tasks.CurrentTaskSchedulerRunner.Run``1(System.Func{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken,System.Threading.Tasks.TaskScheduler)">
            <summary>
            Schedules work with the current or user provided <see cref="T:System.Threading.Tasks.TaskScheduler"/>
            </summary>
            <param name="function">the function to execute.</param>
            <param name="cancellationToken">the token to check for cancellation.</param>
            <param name="scheduler">The optional scheduler to execute the function with.</param>
            <returns>The <see cref="T:System.Threading.Tasks.Task"/> representing the result of the execution.</returns>
        </member>
        <member name="T:Jcd.Threading.Tasks.CustomSchedulerTaskRunner`1">
            <summary>
            A singleton <see cref="T:System.Threading.Tasks.TaskScheduler"/> bound task runner. It ensures all tasks it creates
            are registered with either its own, or a user provided <see cref="T:System.Threading.Tasks.TaskScheduler"/>.
            </summary>
        </member>
        <member name="P:Jcd.Threading.Tasks.CustomSchedulerTaskRunner`1.Scheduler">
            <summary>
            The <see cref="T:System.Threading.Tasks.TaskScheduler"/> used to schedule and execute tasks.
            </summary>
        </member>
        <member name="M:Jcd.Threading.Tasks.CustomSchedulerTaskRunner`1.Run(System.Action,System.Threading.Tasks.TaskScheduler)">
            <summary>
            Schedules work on either the <see cref="T:System.Threading.Tasks.TaskScheduler"/> this type owns or the user provided one. 
            </summary>
            <param name="action">the action to execute.</param>
            <param name="scheduler">The optional scheduler to execute the action with.</param>
            <returns>The <see cref="T:System.Threading.Tasks.Task"/> representing the result of the execution.</returns>
        </member>
        <member name="M:Jcd.Threading.Tasks.CustomSchedulerTaskRunner`1.Run(System.Action,System.Threading.CancellationToken,System.Threading.Tasks.TaskScheduler)">
            <summary>
            Schedules work on either the <see cref="T:System.Threading.Tasks.TaskScheduler"/> this type owns or the user provided one. 
            </summary>
            <param name="action">the action to execute.</param>
            <param name="cancellationToken">The token to check for cancellation.</param>
            <param name="scheduler">The optional scheduler to execute the action with.</param>
            <returns>The <see cref="T:System.Threading.Tasks.Task"/> representing the result of the execution.</returns>
        </member>
        <member name="M:Jcd.Threading.Tasks.CustomSchedulerTaskRunner`1.Run(System.Func{System.Threading.Tasks.Task},System.Threading.Tasks.TaskScheduler)">
            <summary>
            Schedules work on either the <see cref="T:System.Threading.Tasks.TaskScheduler"/> this type owns or the user provided one. 
            </summary>
            <param name="asyncAction">the function to execute.</param>
            <param name="scheduler">The optional scheduler to execute the function with.</param>
            <returns>The <see cref="T:System.Threading.Tasks.Task"/> representing the result of the execution.</returns>
        </member>
        <member name="M:Jcd.Threading.Tasks.CustomSchedulerTaskRunner`1.Run(System.Func{System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Threading.Tasks.TaskScheduler)">
            <summary>
            Schedules work on either the <see cref="T:System.Threading.Tasks.TaskScheduler"/> this type owns or the user provided one. 
            </summary>
            <param name="asyncAction">the action to execute.</param>
            <param name="cancellationToken">The token to check for cancellation.</param>
            <param name="scheduler">The optional scheduler to execute the action with.</param>
            <returns>The <see cref="T:System.Threading.Tasks.Task"/> representing the result of the execution.</returns>
        </member>
        <member name="M:Jcd.Threading.Tasks.CustomSchedulerTaskRunner`1.Run``1(System.Func{``0},System.Threading.Tasks.TaskScheduler)">
            <summary>
            Schedules work on either the <see cref="T:System.Threading.Tasks.TaskScheduler"/> this type owns or the user provided one. 
            </summary>
            <param name="function">the function to execute.</param>
            <param name="scheduler">The optional scheduler to execute the function with.</param>
            <returns>The <see cref="T:System.Threading.Tasks.Task"/> representing the result of the execution.</returns>
        </member>
        <member name="M:Jcd.Threading.Tasks.CustomSchedulerTaskRunner`1.Run``1(System.Func{``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskScheduler)">
            <summary>
            Schedules work on either the <see cref="T:System.Threading.Tasks.TaskScheduler"/> this type owns or the user provided one. 
            </summary>
            <param name="function">the function to execute.</param>
            <param name="cancellationToken">The token to check for cancellation.</param>
            <param name="scheduler">The optional scheduler to execute the function with.</param>
            <returns>The <see cref="T:System.Threading.Tasks.Task"/> representing the result of the execution.</returns>
        </member>
        <member name="M:Jcd.Threading.Tasks.CustomSchedulerTaskRunner`1.Run``1(System.Func{System.Threading.Tasks.Task{``0}},System.Threading.Tasks.TaskScheduler)">
            <summary>
            Schedules work on either the <see cref="T:System.Threading.Tasks.TaskScheduler"/> this type owns or the user provided one. 
            </summary>
            <param name="function">the function to execute.</param>
            <param name="scheduler">The optional scheduler to execute the function with.</param>
            <returns>The <see cref="T:System.Threading.Tasks.Task"/> representing the result of the execution.</returns>
        </member>
        <member name="M:Jcd.Threading.Tasks.CustomSchedulerTaskRunner`1.Run``1(System.Func{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken,System.Threading.Tasks.TaskScheduler)">
            <summary>
            Schedules work on either the <see cref="T:System.Threading.Tasks.TaskScheduler"/> this type owns or the user provided one. 
            </summary>
            <param name="function">the function to execute.</param>
            <param name="cancellationToken">The token to check for cancellation.</param>
            <param name="scheduler">The optional scheduler to execute the function with.</param>
            <returns>The <see cref="T:System.Threading.Tasks.Task"/> representing the result of the execution.</returns>
        </member>
        <member name="T:Jcd.Threading.Tasks.IdleTaskScheduler">
            <summary>
            Provides a mechanism for task scheduling using a round robin mechanism for a pool
            of privately managed threads. Derive from this type to implement your own specialization.
            </summary>
        </member>
        <member name="F:Jcd.Threading.Tasks.IdleTaskScheduler.ProcessorList">
            <summary>
            The list of underlying queue+thread task processors.
            This is provided for advanced use cases.
            </summary>
        </member>
        <member name="P:Jcd.Threading.Tasks.IdleTaskScheduler.Name">
            <summary>
            The name of the instance of the task scheduler.
            </summary>
        </member>
        <member name="P:Jcd.Threading.Tasks.IdleTaskScheduler.Threads">
            <summary>
            Provides access to the underlying threads.
            </summary>
        </member>
        <member name="M:Jcd.Threading.Tasks.IdleTaskScheduler.#ctor(System.Int32,System.Threading.ApartmentState,System.String)">
            <summary>
            Creates an instance of <see cref="T:Jcd.Threading.Tasks.IdleTaskScheduler"/>
            </summary>
            <param name="threadCount">the number of threads to use for scheduling tasks.</param>
            <param name="apartmentState">The <see cref="T:System.Threading.ApartmentState"/> of the threads to create.</param>
            <param name="name">The name of this TaskScheduler instance. Useful for debugging.</param>
        </member>
        <member name="M:Jcd.Threading.Tasks.IdleTaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:Jcd.Threading.Tasks.IdleTaskScheduler.GetScheduledTasks">
            <inheritdoc />
        </member>
        <member name="M:Jcd.Threading.Tasks.IdleTaskScheduler.QueueTask(System.Threading.Tasks.Task)">
            <inheritdoc />
        </member>
        <member name="M:Jcd.Threading.Tasks.IdleTaskScheduler.Dispose(System.Boolean)">
            <summary>
            Cleans up resources and shuts down background threads.
            </summary>
            <param name="disposing">false indicates this is finalizer cleanup.</param>
        </member>
        <member name="M:Jcd.Threading.Tasks.IdleTaskScheduler.Dispose">
            <inheritdoc />
        </member>
        <member name="M:Jcd.Threading.Tasks.IdleTaskScheduler.Finalize">
            <summary>
            Finalizes stuff.
            </summary>
        </member>
        <member name="T:Jcd.Threading.Tasks.TaskSchedulerExtensions">
            <summary>
            Adds various `Run` extension for any <see cref="T:System.Threading.Tasks.TaskScheduler"/> derived type.
            This allows tasks to be scheduled with the desired <see cref="T:System.Threading.Tasks.TaskScheduler"/>
            in a manner similar to `Task.Run` 
            </summary>
        </member>
        <member name="M:Jcd.Threading.Tasks.TaskSchedulerExtensions.Run(System.Threading.Tasks.TaskScheduler,System.Action)">
            <summary>
            Schedules work with the provided <see cref="T:System.Threading.Tasks.TaskScheduler"/>
            </summary>
            <param name="action">the action to execute.</param>
            <param name="scheduler">The scheduler to execute the action with.</param>
            <returns>The <see cref="T:System.Threading.Tasks.Task"/> representing the result of the execution.</returns>
        </member>
        <member name="M:Jcd.Threading.Tasks.TaskSchedulerExtensions.Run(System.Threading.Tasks.TaskScheduler,System.Action,System.Threading.CancellationToken)">
            <summary>
            Schedules work with the provided <see cref="T:System.Threading.Tasks.TaskScheduler"/>
            </summary>
            <param name="action">the action to execute.</param>
            <param name="scheduler">The scheduler to execute the action with.</param>
            <param name="cancellationToken">the token to check for cancellation</param>
            <returns>The <see cref="T:System.Threading.Tasks.Task"/> representing the result of the execution.</returns>
        </member>
        <member name="M:Jcd.Threading.Tasks.TaskSchedulerExtensions.Run(System.Threading.Tasks.TaskScheduler,System.Func{System.Threading.Tasks.Task})">
            <summary>
            Schedules work with the provided <see cref="T:System.Threading.Tasks.TaskScheduler"/>
            </summary>
            <param name="function">the function to execute.</param>
            <param name="scheduler">The scheduler to execute the function with.</param>
            <returns>The <see cref="T:System.Threading.Tasks.Task"/> representing the result of the execution.</returns>
        </member>
        <member name="M:Jcd.Threading.Tasks.TaskSchedulerExtensions.Run(System.Threading.Tasks.TaskScheduler,System.Func{System.Threading.Tasks.Task},System.Threading.CancellationToken)">
            <summary>
            Schedules work with the provided <see cref="T:System.Threading.Tasks.TaskScheduler"/>
            </summary>
            <param name="function">the action to execute.</param>
            <param name="scheduler">The scheduler to execute the function with.</param>
            <param name="cancellationToken">the token to check for cancellation</param>
            <returns>The <see cref="T:System.Threading.Tasks.Task"/> representing the result of the execution.</returns>
        </member>
        <member name="M:Jcd.Threading.Tasks.TaskSchedulerExtensions.Run``1(System.Threading.Tasks.TaskScheduler,System.Func{``0})">
            <summary>
            Schedules work with the provided <see cref="T:System.Threading.Tasks.TaskScheduler"/>
            </summary>
            <param name="function">the function to execute.</param>
            <param name="scheduler">The scheduler to execute the function with.</param>
            <returns>The <see cref="T:System.Threading.Tasks.Task"/> representing the result of the execution.</returns>
        </member>
        <member name="M:Jcd.Threading.Tasks.TaskSchedulerExtensions.Run``1(System.Threading.Tasks.TaskScheduler,System.Func{``0},System.Threading.CancellationToken)">
            <summary>
            Schedules work with the provided <see cref="T:System.Threading.Tasks.TaskScheduler"/>
            </summary>
            <param name="function">the function to execute.</param>
            <param name="scheduler">The scheduler to execute the function with.</param>
            <param name="cancellationToken">the token to check for cancellation</param>
            <returns>The <see cref="T:System.Threading.Tasks.Task"/> representing the result of the execution.</returns>
        </member>
        <member name="M:Jcd.Threading.Tasks.TaskSchedulerExtensions.Run``1(System.Threading.Tasks.TaskScheduler,System.Func{System.Threading.Tasks.Task{``0}})">
            <summary>
            Schedules work with the provided <see cref="T:System.Threading.Tasks.TaskScheduler"/>
            </summary>
            <param name="function">the function to execute.</param>
            <param name="scheduler">The scheduler to execute the function with.</param>
            <returns>The <see cref="T:System.Threading.Tasks.Task"/> representing the result of the execution.</returns>
        </member>
        <member name="M:Jcd.Threading.Tasks.TaskSchedulerExtensions.Run``1(System.Threading.Tasks.TaskScheduler,System.Func{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken)">
            <summary>
            Schedules work with the provided <see cref="T:System.Threading.Tasks.TaskScheduler"/>
            </summary>
            <param name="function">the function to execute.</param>
            <param name="scheduler">The scheduler to execute the function with.</param>
            <param name="cancellationToken">the token to check for cancellation</param>
            <returns>The <see cref="T:System.Threading.Tasks.Task"/> representing the result of the execution.</returns>
        </member>
        <member name="T:Jcd.Threading.ThreadWrapper">
            <summary>
            Provides basic thread management facilities such as Pause, Resume, Stop, Start and
            entering and exiting the idle state. 
            </summary>
            <remarks>
            `Stop` will shutdown the underlying thread completely, and a subsequent call to Start will
            create a brand new thread (with associated cancellation token), while Pause and
            Resume will suspend the thread operations at the appropriate time in the main loop.
            </remarks>
        </member>
        <member name="M:Jcd.Threading.ThreadWrapper.#ctor(System.Boolean,System.String,System.Boolean,System.Int32,System.Int32,System.Threading.ThreadPriority,System.Threading.ApartmentState)">
            <summary>
            Constructs a <see cref="T:Jcd.Threading.ThreadWrapper"/>
            </summary>
            <param name="name">The name of this <see cref="T:Jcd.Threading.ThreadWrapper"/>, propagated to the underlying thread as "{name}.Thread".</param>
            <param name="useBackgroundThread">Indicates if the processing thread is a background thread.</param>
            <param name="autoStart">Indicates if the thread should be automatically started in the constructor.</param>
            <param name="timeToYieldInMs">The amount of CPU time to yield per cycle through the main loop. Only positive numbers will trigger a yield.</param>
            <param name="idleAfterNoWorkDoneCount">the number of iterations with no work before transitioning to the idle state. Set to -1 to disable idle state detection and transition.</param>
            <param name="priority">The priority to start the processing thread at.</param>
            <param name="apartmentState">The apartment state for the underlying thread.</param>
            <remarks>
            <para>
            NOTE: The underlying thread is not created until the first call to `Start` and will change when calling `Stop`
            followed by `Start`. This is because the thread ends completely with a call to `Stop`.
            </para>
            <para>
            If resuming  the same thread is the desired behavior, call `Pause` and `Resume` instead.
            </para> 
            </remarks>
        </member>
        <member name="P:Jcd.Threading.ThreadWrapper.AutoStart">
            <summary>
            A flag indicating if the underlying thread should be immediately started.
            </summary>
        </member>
        <member name="P:Jcd.Threading.ThreadWrapper.ApartmentState">
            <summary>
            The thread apartment state used to create the underlying thread.
            </summary>
        </member>
        <member name="P:Jcd.Threading.ThreadWrapper.Priority">
            <summary>
            The priority with which to create the underlying thread.
            </summary>
        </member>
        <member name="P:Jcd.Threading.ThreadWrapper.UseBackgroundThread">
            <summary>
            A flag indicating if the thread will be a background thread.
            </summary>
        </member>
        <member name="P:Jcd.Threading.ThreadWrapper.YieldEachCycle">
            <summary>
            A flag indicating if CPU time should be yielded every CPU cycle.
            </summary>
        </member>
        <member name="P:Jcd.Threading.ThreadWrapper.TimeToYieldInMs">
            <summary>
            The amount of time to yield each pass through the loop.
            </summary>
        </member>
        <member name="P:Jcd.Threading.ThreadWrapper.IdleAfterNoWorkDoneCount">
            <summary>
            The number of passes through the loop with no work performed before entering the idle state.
            </summary>
        </member>
        <member name="P:Jcd.Threading.ThreadWrapper.Name">
            <summary>
            The name of this instance of the <see cref="T:Jcd.Threading.ThreadWrapper"/>.
            By default the underlying thread will be named as follows:
            `$"{Name}.Thread"`
            </summary>
        </member>
        <member name="P:Jcd.Threading.ThreadWrapper.Thread">
            <summary>
            Provides direct access to the underlying thread.
            </summary>
        </member>
        <member name="M:Jcd.Threading.ThreadWrapper.ThreadProc">
            <summary>
            The main thread control loop. 
            </summary>
            <remarks>
            <para>
            You should only override this for advanced use cases.
            Override `GetShouldContinue` for determining when the thread ends.
            Override `PerformWork` to do a single unit of work on each pass through the loop.
            </para>
            <para>
            If you choose to override this and supply your own main loop for the thread,
            You will need to check for cancellation, Call `IdleWait` and `PauseWait`
            at the appropriate time in your loop, as well as `YieldCpuTime` to ensure
            your thread doesn't monopolize the CPU.
            use cases. 
            </para>
            </remarks>
        </member>
        <member name="M:Jcd.Threading.ThreadWrapper.PerformWork(System.Threading.CancellationToken)">
            <summary>
            Performs a single unit of work. Implement in derived types not overriding ThreadProc.
            </summary>
            <param name="token">the token cancellation token to use</param>
            <returns>
            True if meaningful work was done. False if the it should transition to idle
            after this call.
            </returns>
        </member>
        <member name="M:Jcd.Threading.ThreadWrapper.YieldCpuTime(System.Int32)">
            <summary>
            Yields very small amounts of CPU time. This can approach 1ms.
            Thread.Sleep and Task.Delay will wait at least 15ms.
            </summary>
            <param name="timeToYieldInMilliseconds">The amount of time to wait, in milliseconds.</param>
        </member>
        <member name="P:Jcd.Threading.ThreadWrapper.CancellationToken">
            <summary>
            Gives derived types access to the <see cref="P:Jcd.Threading.ThreadWrapper.CancellationToken"/>
            </summary>
        </member>
        <member name="P:Jcd.Threading.ThreadWrapper.IsStarted">
            <summary>
            Gets a flag indicating if the item processing loop has started.
            </summary>
        </member>
        <member name="P:Jcd.Threading.ThreadWrapper.IsPaused">
            <summary>
            Gets a flag indicating if the item processing is currently paused.
            </summary>
        </member>
        <member name="P:Jcd.Threading.ThreadWrapper.IsIdle">
            <summary>
            Gets a flag indicating if the item processing is currently paused.
            </summary>
        </member>
        <member name="M:Jcd.Threading.ThreadWrapper.GetShouldContinue(System.Threading.CancellationToken)">
            <summary>
            Determines if the main thread loop should continue looping.
            </summary>
            <param name="token">the token to check for cancellation</param>
            <returns>True if the main thread loop should continue.</returns>
        </member>
        <member name="M:Jcd.Threading.ThreadWrapper.PerformThreadStateCleanup">
            <summary>
            Ensures thread state is reset to final, including cancellation.
            This is called as a thread is exiting..
            </summary>
        </member>
        <member name="M:Jcd.Threading.ThreadWrapper.IdleWait(System.Threading.CancellationToken)">
            <summary>
            Wait in idle state, if the IsIdle flag is set.
            </summary>
            <param name="token">the token to observe for cancellation.</param>
            <returns>true if we waited in the idle state.</returns>
        </member>
        <member name="M:Jcd.Threading.ThreadWrapper.PauseWait(System.Threading.CancellationToken)">
            <summary>
            Wait in the paused state if the IsPaused flag is set.
            </summary>
            <param name="token">the token to observe for cancellation.</param>
        </member>
        <member name="M:Jcd.Threading.ThreadWrapper.EnterIdleState">
            <summary>
            Sets the thread into the idle state.
            </summary>
        </member>
        <member name="M:Jcd.Threading.ThreadWrapper.ExitIdleState">
            <summary>
            Causes the owning thread to resume. This must be called by an external thread.
            </summary>
        </member>
        <member name="M:Jcd.Threading.ThreadWrapper.EnterPausedState">
            <summary>
            Puts the thread into the Paused state.
            </summary>
        </member>
        <member name="M:Jcd.Threading.ThreadWrapper.ExitPausedState">
            <summary>
            Causes the thread to exit the paused state. This must be called by
            an external thread.
            </summary>
        </member>
        <member name="M:Jcd.Threading.ThreadWrapper.CancelAllProcessing">
            <summary>
            Cancels the internally managed <see cref="P:Jcd.Threading.ThreadWrapper.CancellationToken"/>
            and ignores any exceptions. 
            </summary>
        </member>
        <member name="M:Jcd.Threading.ThreadWrapper.Pause">
            <summary>
            Pauses the retrieval and processing of queued items. 
            </summary>
        </member>
        <member name="M:Jcd.Threading.ThreadWrapper.Resume">
            <summary>
            Resumes item processing.
            </summary>
        </member>
        <member name="M:Jcd.Threading.ThreadWrapper.Start">
            <summary>
            Starts the processing of queued items.
            </summary>
        </member>
        <member name="M:Jcd.Threading.ThreadWrapper.Stop">
            <summary>
            Shuts down the thread through the CancellationToken
            </summary>
        </member>
        <member name="M:Jcd.Threading.ThreadWrapper.Dispose(System.Boolean)">
            <summary>
            Disposes of resources.
            </summary>
            <param name="disposing">indicates if it's actually being disposed vs garbage collected</param>
        </member>
        <member name="M:Jcd.Threading.ThreadWrapper.Dispose">
            <inheritdoc />
        </member>
        <member name="M:Jcd.Threading.ThreadWrapper.Finalize">
            <summary>
            finalizes the object.
            </summary>
        </member>
        <member name="T:Jcd.Threading.TicketLock">
            <summary>
            Provides a naiive implementation of a <see href="https://en.wikipedia.org/wiki/Ticket_lock">Ticket lock (wikipedia)</see> with cancellation support.
            </summary>
            <remarks>
            <para>
            For a technical reference on Ticket Locks see: <see href="https://medium.com/@shivajiofficial5088/ticket-locking-algorithm-fair-lock-delivery-mechanism-fdfe04b0b94b">Ticket Locking Algorithm : Fair Lock Delivery Mechanism</see>
            </para> 
            <para>
            For further reading see the <see href="https://en.wikipedia.org/wiki/Ticket_lock">Wikipedia Article on Ticket locks</see>.
            </para> 
            </remarks>
        </member>
        <member name="P:Jcd.Threading.TicketLock.MaxTicketCount">
            <summary>
            The maximum number of possible tickets. (At 1 per 20ms this should last 350 years of continuous run time.)
            </summary>
        </member>
        <member name="P:Jcd.Threading.TicketLock.NowServing">
            <summary>
            The ticket currently holding the lock.
            </summary>
        </member>
        <member name="P:Jcd.Threading.TicketLock.CurrentCount">
            <summary>
            The total number of pending tickets.
            </summary>
        </member>
        <member name="M:Jcd.Threading.TicketLock.Release">
            <summary>
            Increment's NowServing so that the next thread
            can begin processing.
            </summary>
        </member>
        <member name="M:Jcd.Threading.TicketLock.GetResourceLock">
            <summary>
            Creates an <see cref="T:Jcd.Threading.TicketLockResourceLock"/>.
            </summary>
            <remarks>
            WARNING: This is for advanced use cases only. Failing to release the lock
            will deadlock all other tickets with a larger TicketId. However, calling release
            on the ticket before this <see cref="T:Jcd.Threading.TicketLock"/> has NowServing set to the
            new ticket's ID will cause a race condition between the code locked by
            this specific ticket and the next immediately higher lock.  
            </remarks>
            <returns>The new ticket.</returns>
        </member>
        <member name="M:Jcd.Threading.TicketLock.Lock">
            <summary>
            Creates an <see cref="T:Jcd.Threading.TicketLockResourceLock"/> and waits on it.
            </summary>
            <returns>The ticket once the lock is acquired.</returns>
        </member>
        <member name="M:Jcd.Threading.TicketLock.Lock(System.Threading.CancellationToken)">
            <summary>
            Creates an <see cref="T:Jcd.Threading.TicketLockResourceLock"/> and waits on it.
            </summary>
            <param name="token">The token to listen for cancellation on.</param>
            <returns>The ticket once the lock is acquired.</returns>
        </member>
        <member name="M:Jcd.Threading.TicketLock.LockAsync">
            <summary>
            Asynchronously creates an <see cref="T:Jcd.Threading.TicketLockResourceLock"/> and waits on it.
            </summary>
            <returns>The ticket once the lock is acquired.</returns>
        </member>
        <member name="M:Jcd.Threading.TicketLock.LockAsync(System.Threading.CancellationToken)">
            <summary>
            Asynchronously creates an <see cref="T:Jcd.Threading.TicketLockResourceLock"/> and waits on it.
            </summary>
            <param name="token">The token to listen for cancellation on.</param>
            <returns>The ticket once the lock is acquired.</returns>
        </member>
        <member name="T:Jcd.Threading.TicketLockResourceLock">
            <summary>
            Provides a mechanism for establishing and releasing locks on a <see cref="T:Jcd.Threading.TicketLock"/>.
            </summary>
            <para>
            Do not share instances of this type across threads. Behavior can be unpredictable.
            Instances of this type are created by <see cref="T:Jcd.Threading.TicketLock"/> to create a more
            consistent experience when using synchronization primitives with other
            <see cref="T:Jcd.Threading.IResourceLock"/> types.
            </para> 
        </member>
        <member name="P:Jcd.Threading.TicketLockResourceLock.TicketId">
            <summary>
            The ticked Id for this instance.
            </summary>
        </member>
        <member name="P:Jcd.Threading.TicketLockResourceLock.IsCanceled">
            <summary>
            Indicates if the ticket has been canceled.
            </summary>
        </member>
        <member name="M:Jcd.Threading.TicketLockResourceLock.Wait">
            <summary>
            Waits for the `NowServing` on the owning <see cref="T:Jcd.Threading.TicketLock"/>
            to match its own `TicketId`
            </summary>
            <returns>true if the lock was acquired, false otherwise (usually a cancellation)</returns>
        </member>
        <member name="M:Jcd.Threading.TicketLockResourceLock.Wait(System.Threading.CancellationToken)">
            <summary>
            Waits for the `NowServing` on the owning <see cref="T:Jcd.Threading.TicketLock"/>
            to match its own `TicketId`
            </summary>
            <param name="token">the token to observe for cancellation.</param>
            <returns>true if the lock was acquired, false otherwise (usually a cancellation)</returns>
        </member>
        <member name="M:Jcd.Threading.TicketLockResourceLock.WaitAsync">
            <summary>
            Asynchronously Waits for the `NowServing` on the owning <see cref="T:Jcd.Threading.TicketLock"/>
            to match its own `TicketId`
            </summary>
            <returns>true if the lock was acquired, false otherwise (usually a cancellation)</returns>
        </member>
        <member name="M:Jcd.Threading.TicketLockResourceLock.WaitAsync(System.Threading.CancellationToken)">
            <summary>
            Waits for the `NowServing` on the owning <see cref="T:Jcd.Threading.TicketLock"/>
            to match its own `TicketId`
            </summary>
            <param name="token">the token to observe for cancellation.</param>
            <returns>true if the lock was acquired, false otherwise (usually a cancellation)</returns>
        </member>
        <member name="M:Jcd.Threading.TicketLockResourceLock.Cancel">
            <summary>
            Cancels the ticket. This will register a background thread to do cleanup.
            </summary>
        </member>
        <member name="M:Jcd.Threading.TicketLockResourceLock.Release">
            <inheritdoc />
        </member>
        <member name="M:Jcd.Threading.TicketLockResourceLock.Dispose">
            <summary>
            Releases any locks held.
            </summary>
        </member>
    </members>
</doc>
