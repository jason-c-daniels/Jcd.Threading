<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Jcd.Tasks</name>
    </assembly>
    <members>
        <member name="T:Jcd.Tasks.CurrentSchedulerTaskRunner">
            <summary>
            A static class that schedules tasks on the current <see cref="T:System.Threading.Tasks.TaskScheduler"/> or
            a user provided <see cref="T:System.Threading.Tasks.TaskScheduler"/> if null is passed in or none is specified.
            </summary>
        </member>
        <member name="P:Jcd.Tasks.CurrentSchedulerTaskRunner.Scheduler">
            <summary>
            The current <see cref="T:System.Threading.Tasks.TaskScheduler"/>
            </summary>
        </member>
        <member name="M:Jcd.Tasks.CurrentSchedulerTaskRunner.Run(System.Action,System.Threading.Tasks.TaskScheduler)">
            <summary>
            Schedules work with the current or user provided <see cref="T:System.Threading.Tasks.TaskScheduler"/>
            </summary>
            <param name="action">the action to run</param>
            <param name="scheduler">The scheduler to use, pass null to use the the current one. </param>
            <returns></returns>
        </member>
        <member name="M:Jcd.Tasks.CurrentSchedulerTaskRunner.Run(System.Action,System.Threading.CancellationToken,System.Threading.Tasks.TaskScheduler)">
            <summary>
            Schedules work with the current or user provided <see cref="T:System.Threading.Tasks.TaskScheduler"/>
            </summary>
            <param name="action">the action to execute.</param>
            <param name="cancellationToken">the token to check for cancellation.</param>
            <param name="scheduler">The optional scheduler to execute the action with.</param>
            <returns>The <see cref="T:System.Threading.Tasks.Task"/> representing the result of the execution.</returns>
        </member>
        <member name="M:Jcd.Tasks.CurrentSchedulerTaskRunner.Run(System.Func{System.Threading.Tasks.Task},System.Threading.Tasks.TaskScheduler)">
            <summary>
            Schedules work with the current or user provided <see cref="T:System.Threading.Tasks.TaskScheduler"/>
            </summary>
            <param name="function">the function to execute.</param>
            <param name="scheduler">The optional scheduler to execute the function with.</param>
            <returns>The <see cref="T:System.Threading.Tasks.Task"/> representing the result of the execution.</returns>
        </member>
        <member name="M:Jcd.Tasks.CurrentSchedulerTaskRunner.Run(System.Func{System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Threading.Tasks.TaskScheduler)">
            <summary>
            Schedules work with the current or user provided <see cref="T:System.Threading.Tasks.TaskScheduler"/>
            </summary>
            <param name="function">the function to execute.</param>
            <param name="cancellationToken">the token to check for cancellation.</param>
            <param name="scheduler">The optional scheduler to execute the function with.</param>
            <returns>The <see cref="T:System.Threading.Tasks.Task"/> representing the result of the execution.</returns>
        </member>
        <member name="M:Jcd.Tasks.CurrentSchedulerTaskRunner.Run``1(System.Func{``0},System.Threading.Tasks.TaskScheduler)">
            <summary>
            Schedules work with the current or user provided <see cref="T:System.Threading.Tasks.TaskScheduler"/>
            </summary>
            <param name="function">the function to execute.</param>
            <param name="scheduler">The optional scheduler to execute the function with.</param>
            <returns>The <see cref="T:System.Threading.Tasks.Task"/> representing the result of the execution.</returns>
        </member>
        <member name="M:Jcd.Tasks.CurrentSchedulerTaskRunner.Run``1(System.Func{``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskScheduler)">
            <summary>
            Schedules work with the current or user provided <see cref="T:System.Threading.Tasks.TaskScheduler"/>
            </summary>
            <param name="function">the function to execute.</param>
            <param name="cancellationToken">the token to check for cancellation.</param>
            <param name="scheduler">The optional scheduler to execute the function with.</param>
            <returns>The <see cref="T:System.Threading.Tasks.Task"/> representing the result of the execution.</returns>
        </member>
        <member name="M:Jcd.Tasks.CurrentSchedulerTaskRunner.Run``1(System.Func{System.Threading.Tasks.Task{``0}},System.Threading.Tasks.TaskScheduler)">
            <summary>
            Schedules work with the current or user provided <see cref="T:System.Threading.Tasks.TaskScheduler"/>
            </summary>
            <param name="function">the function to execute.</param>
            <param name="scheduler">The optional scheduler to execute the function with.</param>
            <returns>The <see cref="T:System.Threading.Tasks.Task"/> representing the result of the execution.</returns>
        </member>
        <member name="M:Jcd.Tasks.CurrentSchedulerTaskRunner.Run``1(System.Func{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken,System.Threading.Tasks.TaskScheduler)">
            <summary>
            Schedules work with the current or user provided <see cref="T:System.Threading.Tasks.TaskScheduler"/>
            </summary>
            <param name="function">the function to execute.</param>
            <param name="cancellationToken">the token to check for cancellation.</param>
            <param name="scheduler">The optional scheduler to execute the function with.</param>
            <returns>The <see cref="T:System.Threading.Tasks.Task"/> representing the result of the execution.</returns>
        </member>
        <member name="T:Jcd.Tasks.CustomSchedulerTaskRunner`1">
            <summary>
            A singleton <see cref="T:System.Threading.Tasks.TaskScheduler"/> bound task runner. It ensures all tasks it creates
            are registered with either its own, or a user provided <see cref="T:System.Threading.Tasks.TaskScheduler"/>.
            </summary>
        </member>
        <member name="P:Jcd.Tasks.CustomSchedulerTaskRunner`1.Scheduler">
            <summary>
            The <see cref="T:System.Threading.Tasks.TaskScheduler"/> used to schedule and execute tasks.
            </summary>
        </member>
        <member name="M:Jcd.Tasks.CustomSchedulerTaskRunner`1.Run(System.Action,System.Threading.Tasks.TaskScheduler)">
            <summary>
            Schedules work on either the <see cref="T:System.Threading.Tasks.TaskScheduler"/> this type owns or the user provided one. 
            </summary>
            <param name="action">the action to execute.</param>
            <param name="scheduler">The optional scheduler to execute the action with.</param>
            <returns>The <see cref="T:System.Threading.Tasks.Task"/> representing the result of the execution.</returns>
        </member>
        <member name="M:Jcd.Tasks.CustomSchedulerTaskRunner`1.Run(System.Action,System.Threading.CancellationToken,System.Threading.Tasks.TaskScheduler)">
            <summary>
            Schedules work on either the <see cref="T:System.Threading.Tasks.TaskScheduler"/> this type owns or the user provided one. 
            </summary>
            <param name="action">the action to execute.</param>
            <param name="cancellationToken">The token to check for cancellation.</param>
            <param name="scheduler">The optional scheduler to execute the action with.</param>
            <returns>The <see cref="T:System.Threading.Tasks.Task"/> representing the result of the execution.</returns>
        </member>
        <member name="M:Jcd.Tasks.CustomSchedulerTaskRunner`1.Run(System.Func{System.Threading.Tasks.Task},System.Threading.Tasks.TaskScheduler)">
            <summary>
            Schedules work on either the <see cref="T:System.Threading.Tasks.TaskScheduler"/> this type owns or the user provided one. 
            </summary>
            <param name="asyncAction">the function to execute.</param>
            <param name="scheduler">The optional scheduler to execute the function with.</param>
            <returns>The <see cref="T:System.Threading.Tasks.Task"/> representing the result of the execution.</returns>
        </member>
        <member name="M:Jcd.Tasks.CustomSchedulerTaskRunner`1.Run(System.Func{System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Threading.Tasks.TaskScheduler)">
            <summary>
            Schedules work on either the <see cref="T:System.Threading.Tasks.TaskScheduler"/> this type owns or the user provided one. 
            </summary>
            <param name="asyncAction">the action to execute.</param>
            <param name="cancellationToken">The token to check for cancellation.</param>
            <param name="scheduler">The optional scheduler to execute the action with.</param>
            <returns>The <see cref="T:System.Threading.Tasks.Task"/> representing the result of the execution.</returns>
        </member>
        <member name="M:Jcd.Tasks.CustomSchedulerTaskRunner`1.Run``1(System.Func{``0},System.Threading.Tasks.TaskScheduler)">
            <summary>
            Schedules work on either the <see cref="T:System.Threading.Tasks.TaskScheduler"/> this type owns or the user provided one. 
            </summary>
            <param name="function">the function to execute.</param>
            <param name="scheduler">The optional scheduler to execute the function with.</param>
            <returns>The <see cref="T:System.Threading.Tasks.Task"/> representing the result of the execution.</returns>
        </member>
        <member name="M:Jcd.Tasks.CustomSchedulerTaskRunner`1.Run``1(System.Func{``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskScheduler)">
            <summary>
            Schedules work on either the <see cref="T:System.Threading.Tasks.TaskScheduler"/> this type owns or the user provided one. 
            </summary>
            <param name="function">the function to execute.</param>
            <param name="cancellationToken">The token to check for cancellation.</param>
            <param name="scheduler">The optional scheduler to execute the function with.</param>
            <returns>The <see cref="T:System.Threading.Tasks.Task"/> representing the result of the execution.</returns>
        </member>
        <member name="M:Jcd.Tasks.CustomSchedulerTaskRunner`1.Run``1(System.Func{System.Threading.Tasks.Task{``0}},System.Threading.Tasks.TaskScheduler)">
            <summary>
            Schedules work on either the <see cref="T:System.Threading.Tasks.TaskScheduler"/> this type owns or the user provided one. 
            </summary>
            <param name="function">the function to execute.</param>
            <param name="scheduler">The optional scheduler to execute the function with.</param>
            <returns>The <see cref="T:System.Threading.Tasks.Task"/> representing the result of the execution.</returns>
        </member>
        <member name="M:Jcd.Tasks.CustomSchedulerTaskRunner`1.Run``1(System.Func{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken,System.Threading.Tasks.TaskScheduler)">
            <summary>
            Schedules work on either the <see cref="T:System.Threading.Tasks.TaskScheduler"/> this type owns or the user provided one. 
            </summary>
            <param name="function">the function to execute.</param>
            <param name="cancellationToken">The token to check for cancellation.</param>
            <param name="scheduler">The optional scheduler to execute the function with.</param>
            <returns>The <see cref="T:System.Threading.Tasks.Task"/> representing the result of the execution.</returns>
        </member>
        <member name="T:Jcd.Tasks.ItemProcessor`1">
            <summary>
            An item processor that calls a delegate on each item enqueued with it. 
            </summary>
            <remarks>
            You must ensure all shared resources owned by the enqueued items have their access
            synchronized appropriately. This type only synchronizes access to internal data.
            </remarks>
        </member>
        <member name="P:Jcd.Tasks.ItemProcessor`1.Thread">
            <summary>
            Provides direct access to the underlying thread.
            </summary>
        </member>
        <member name="P:Jcd.Tasks.ItemProcessor`1.Items">
            <summary>
            
            </summary>
        </member>
        <member name="P:Jcd.Tasks.ItemProcessor`1.Count">
            <summary>
            The number of items in the internal queue.
            </summary>
        </member>
        <member name="P:Jcd.Tasks.ItemProcessor`1.HasItems">
            <summary>
            Gets a flag indicating if there are any pending items.
            </summary>
        </member>
        <member name="P:Jcd.Tasks.ItemProcessor`1.IsStarted">
            <summary>
            Gets a flag indicating if the item processing loop has started.
            </summary>
        </member>
        <member name="P:Jcd.Tasks.ItemProcessor`1.IsPaused">
            <summary>
            Gets a flag indicating if the item processing is currently paused.
            </summary>
        </member>
        <member name="P:Jcd.Tasks.ItemProcessor`1.IsIdle">
            <summary>
            Gets a flag indicating if the item processing is currently paused.
            </summary>
        </member>
        <member name="M:Jcd.Tasks.ItemProcessor`1.#ctor(System.Action{`0},System.Boolean,System.String,System.Boolean,System.Threading.ThreadPriority,System.Threading.ApartmentState)">
            <summary>
            Constructs a <see cref="T:Jcd.Tasks.ItemProcessor`1"/>
            </summary>
            <param name="action">The action to execute on each item.</param>
            <param name="name">The name of this ItemProcessor, propagated to the underlying thread.</param>
            <param name="useBackgroundThread">Indicates if the processing thread is a background thread.</param>
            <param name="autoStart">Indicates if the thread should be automatically started.</param>
            <param name="priority">The priority to start the processing thread at.</param>
            <param name="apartmentState">The apartment state for the underlying thread.</param>
        </member>
        <member name="M:Jcd.Tasks.ItemProcessor`1.Enqueue(`0)">
            <summary>
            Enqueues a <see cref="!:TItem"/>. This is a "fire and forget" method. Control is immediately
            returned to the caller.
            </summary>
            <param name="item">The action to enqueue.</param>
        </member>
        <member name="M:Jcd.Tasks.ItemProcessor`1.Pause">
            <summary>
            Pauses the retrieval and processing of queued items. 
            </summary>
        </member>
        <member name="M:Jcd.Tasks.ItemProcessor`1.Resume">
            <summary>
            Resumes item processing.
            </summary>
        </member>
        <member name="M:Jcd.Tasks.ItemProcessor`1.PauseAsync">
            <summary>
            Pauses the retrieval and execution of queued items.
            </summary>
        </member>
        <member name="M:Jcd.Tasks.ItemProcessor`1.ResumeAsync">
            <summary>
            Resumes item processing.
            </summary>
        </member>
        <member name="M:Jcd.Tasks.ItemProcessor`1.Start">
            <summary>
            Starts the processing of queued items.
            </summary>
        </member>
        <member name="M:Jcd.Tasks.ItemProcessor`1.Dispose">
            <inheritdoc />
        </member>
        <member name="T:Jcd.Tasks.NamespaceDoc">
            <summary>
            Provides types and extension methods to assist with the creation, execution, and
            management of unstarted <see cref="T:System.Threading.Tasks.Task"/> instances.
            </summary>
        </member>
        <member name="T:Jcd.Tasks.ReaderWriterLockSlimExtensions">
            <summary>
            A set of extension methods to simplify using a <see cref="T:System.Threading.ReaderWriterLockSlim"/>
            to ensure the correct pair of EnterRead+ExitRead, EnterUpgradeableRead+ExitUpgradeableRead,
            and EnterWrite+ExitWrite are called.
            </summary>
        </member>
        <member name="T:Jcd.Tasks.SemaphoreSlimExtensions">
            <summary>
            A set of extension methods to simplify using a <see cref="T:System.Threading.SemaphoreSlim"/>
            to ensure that Release is called for every Wait or WaitAsync. Useful for
            ensuring synchronized access to data for short lived operations.
            </summary>
        </member>
        <member name="M:Jcd.Tasks.SemaphoreSlimExtensions.Use(System.Threading.SemaphoreSlim)">
            <summary>
            Waits on the semaphore, and returns an <see cref="T:System.IDisposable"/> that calls Release.
            </summary>
            <param name="sem">the semaphore to use.</param>
            <returns>an <see cref="T:System.IDisposable"/> that calls Release in its Dispose method.</returns>
        </member>
        <member name="M:Jcd.Tasks.SemaphoreSlimExtensions.Use(System.Threading.SemaphoreSlim,System.Threading.CancellationToken)">
            <summary>
            Waits on the semaphore, and returns an <see cref="T:System.IDisposable"/> that calls Release.
            </summary>
            <param name="sem">the semaphore to use.</param>
            <param name="token">A cancellation token to use during the wait.</param>
            <returns>an <see cref="T:System.IDisposable"/> that calls Release in its Dispose method.</returns>
        </member>
        <member name="M:Jcd.Tasks.SemaphoreSlimExtensions.UseAsync(System.Threading.SemaphoreSlim)">
            <summary>
            Asynchronously waits on the semaphore, and returns an <see cref="T:System.IDisposable"/> that calls Release.
            </summary>
            <param name="sem">the semaphore to use.</param>
            <returns>A <see cref="T:System.Threading.Tasks.Task`1"/> for an <see cref="T:System.IDisposable"/> that calls Release in its Dispose method.</returns>
        </member>
        <member name="M:Jcd.Tasks.SemaphoreSlimExtensions.UseAsync(System.Threading.SemaphoreSlim,System.Threading.CancellationToken)">
            <summary>
            Asynchronously waits on the semaphore, and returns an <see cref="T:System.IDisposable"/> that calls Release.
            </summary>
            <param name="sem">the semaphore to use.</param>
            <param name="token">A cancellation token to use during the wait.</param>
            <returns>A <see cref="T:System.Threading.Tasks.Task`1"/> for an <see cref="T:System.IDisposable"/> that calls Release in its Dispose method.</returns>
        </member>
        <member name="T:Jcd.Tasks.SimpleThreadedTaskScheduler">
            <summary>
            A <see cref="T:System.Threading.Tasks.TaskScheduler"/> derived base type that runs <see cref="T:System.Threading.Tasks.Task"/> instances
            in a fixed size pool of threads. Inlining is disabled by default to ensure only
            the threads managed by this <see cref="T:System.Threading.Tasks.TaskScheduler"/> will process the tasks.
            </summary>
        </member>
        <member name="M:Jcd.Tasks.SimpleThreadedTaskScheduler.GetScheduledTasks">
            <inheritdoc />
        </member>
        <member name="P:Jcd.Tasks.SimpleThreadedTaskScheduler.Threads">
            <summary>
            The set of threads that will process Tasks. This is provided for
            advanced use cases where an action needs to be taken on the entire
            pool of threads.
            </summary>
        </member>
        <member name="M:Jcd.Tasks.SimpleThreadedTaskScheduler.Shutdown">
            <summary>
            Signals the underlying threads that the <see cref="T:System.Threading.Tasks.TaskScheduler"/>
            is being shutdown (i.e. disposed of). Threads should shortly thereafter. 
            </summary>
        </member>
        <member name="M:Jcd.Tasks.SimpleThreadedTaskScheduler.#ctor(System.Int32,System.Threading.ApartmentState)">
            <summary>
            Constructs an instance of the type.
            </summary>
            <param name="threadCount">The number of threads to create.</param>
            <param name="state">the thread apartment state setting for all threads.</param>
        </member>
        <member name="M:Jcd.Tasks.SimpleThreadedTaskScheduler.QueueTask(System.Threading.Tasks.Task)">
            <inheritdoc />
        </member>
        <member name="M:Jcd.Tasks.SimpleThreadedTaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
            <summary>
            The method to attempt executing a Task in the calling thread's context.
            This is disabled by default. See remarks for discussion. 
            </summary>
            <param name="task">the task to try inlining</param>
            <param name="taskWasPreviouslyQueued">indicates if it was previously queued with this scheduler</param>
            <returns>false, by default, may be overridden in a derived type.</returns>
            <remarks>
            The default implementation for this scheduler guarantees only its threads are processing tasks, so we cannot
            inline operations as inlining executes the task on the ThreadPool, which may not meet the same requirements as our
            dedicated threads.
            </remarks>
        </member>
        <member name="M:Jcd.Tasks.SimpleThreadedTaskScheduler.Dispose(System.Boolean)">
            <summary>
            Disposes unmanaged resources  
            </summary>
            <param name="disposing">indicates if it's disposing.</param>
        </member>
        <member name="M:Jcd.Tasks.SimpleThreadedTaskScheduler.Dispose">
            <inheritdoc />
        </member>
        <member name="T:Jcd.Tasks.SingleWriterMultipleReaderValue`1">
            <summary>
            A value wrapper for a <see cref="T:System.Threading.ManualResetEventSlim"/> to block read access while
            the sole owning thread is updating the value. Otherwise reads are not blocked.
            </summary>
            <remarks>
            It is the consumers responsibility to use this class as intended.
            Multiple writes are not blocked. Unpredictable behavior may result if multiple
            threads set the value at the same time.
            </remarks>
            <typeparam name="T">The data type to synchronize access to.</typeparam>
        </member>
        <member name="M:Jcd.Tasks.SingleWriterMultipleReaderValue`1.Dispose">
            <inheritdoc />
        </member>
        <member name="P:Jcd.Tasks.SingleWriterMultipleReaderValue`1.Value">
             <summary>
             Get or sets the synchronized value.
             </summary>
             <example>
             <code>
             var sv = new SynchronizedValue&lt;int&gt;(15);
             
             // get the value
             var theValue = sv.Value;
            
             // set the value
             sv.Value = theValue + 10;
             
             </code>
             </example>
        </member>
        <member name="M:Jcd.Tasks.SingleWriterMultipleReaderValue`1.GetValue">
            <summary>
            Retrieves the current value. If another thread edits the value, moment later a subsequent
            call will yield a different result. 
            </summary>
            <returns>The current value as of establishing the lock.</returns>
            <example>
            <code>
            var sv = new SynchronizedValue&lt;int&gt;(15);
            
            // get the value
            setValue = sv.GetValue(20);
            
            </code>
            </example>
        </member>
        <member name="M:Jcd.Tasks.SingleWriterMultipleReaderValue`1.GetValueAsync">
            <summary>
            Gets the value in an async friendly manner.
            </summary>
            <returns>A <see cref="T:System.Threading.Tasks.Task`1"/> containing the retrieved value.</returns>
            <example>
            <code>
            var sv = new SynchronizedValue&lt;int&gt;(15);
            
            // get the value
            await setValue = sv.GetValueAsync(20);
            
            </code>
            </example>
        </member>
        <member name="M:Jcd.Tasks.SingleWriterMultipleReaderValue`1.SetValue(`0)">
            <summary>
            Sets the current value to the provided value.
            </summary>
            <param name="value">The provided value.</param>
            <returns>The provided value.</returns>
            <example>
            <code>
            var sv = new SynchronizedValue&lt;int&gt;();
            
            // set the value to 10.
            setValue = sv.SetValue(10);
            
            // set the value to 20.
            setValue = sv.SetValue(20);
            
            </code>
            </example>
        </member>
        <member name="M:Jcd.Tasks.SingleWriterMultipleReaderValue`1.SetValueAsync(`0)">
            <summary>
            Sets the current value to the provided value.
            </summary>
            <param name="value">The provided value.</param>
            <returns>A <see cref="T:System.Threading.Tasks.Task`1"/> containing the provided value.</returns>
            <example>
            <code>
            var sv = new SynchronizedValue&lt;int&gt;();
            
            // set the value to 10.
            await setValue = sv.SetValueAsync(10);
            
            // set the value to 20.
            await setValue = sv.SetValueAsync(20);
            
            </code>
            </example>
        </member>
        <member name="M:Jcd.Tasks.SingleWriterMultipleReaderValue`1.ChangeValue(System.Func{`0,`0})">
             <summary>
             Calls the provided function, passing in the current value, and assigns the result
             of the function call, to the current value. <b>This is not recursively reentrant.
             see remarks for details.</b>
             </summary>
             <param name="func">
             A function to call which receives the current value, modifies it, and returns the
             modified result.
             </param>
             <returns>The modified value.</returns>
             <example>
             Standard usage: pass in a function to manipulate the current value.
             <code>
             var sv = new SynchronizedValue&lt;int&gt;();
             
             // increment the value by one.
             var changedValue = sv.Do(x => x + 1);
             
             // increment the value by two.
             changedValue = sv.Do(x => x + 2);
             
             </code>
             </example>
             <remarks>
             <para>
             <b>WARNING:</b>This is <b>not</b> a recursively reentrant method. Never write code like
             the following.
             </para>
             <code>
             var sv=new SynchronizedValue&lt;int&gt;(10);
            
             // deadlock yourself in a single line of code!
             var changedValue = sv.Do(x=>sv.Value+10);
             </code>
             </remarks>
        </member>
        <member name="M:Jcd.Tasks.SingleWriterMultipleReaderValue`1.ChangeValueAsync(System.Func{`0,System.Threading.Tasks.Task{`0}})">
             <summary>
             Calls the provided function, passing in the current value, and assigns the result
             of the function call, to the current value. <b>This is not recursively reentrant.
             see remarks for details.</b>
             </summary>
             <param name="func">The function to call.</param>
             <returns>A <see cref="T:System.Threading.Tasks.Task`1"/> containing the modified value.</returns>
             <example>
             Standard usage: pass in a function to manipulate the current value.
             <code>
             var sv = new SynchronizedValue&lt;int&gt;();
             
             // increment the value by one.
             var changedValue = await sv.ChangeValueAsync(x => x + 1);
             
             // increment the value by two.
             changedValue = await sv.ChangeValueAsync(x => x + 2);
             
             // Perform some operation that requires the value to remain unchanged during the operation.
             var sameValue = await sv.ChangeValueAsync(x => { DoSomething(x); return x;});
             </code>
             </example>
             <remarks>
             <para>
             <b>WARNING:</b>This is <b>not</b> a recursively reentrant method. Never write code like
             the following.
             </para>
             <code>
             var sv=new SynchronizedValue&lt;int&gt;(10);
            
             // deadlock yourself in a single line of code!
             var changedValue = await sv.ChangeValueAsync(x=>sv.Value+10);
             </code>
             </remarks>
        </member>
        <member name="T:Jcd.Tasks.SynchronizedValue`1">
            <summary>
            Provides a simple async-safe and thread-safe method of setting, getting, acting on,
            and altering values shared among tasks and threads.
            </summary>
            <param name="val">The value to initialize this to</param>
            <typeparam name="T">The data type to synchronize access to.</typeparam>
            <remarks>
            <para>
            While this provides a method of easily ensuring any one shared value is appropriately
            locked during setting or getting, you still need to thoroughly understand your
            use case. For example, having two <see cref="T:Jcd.Tasks.SynchronizedValue`1"/> instances accessed
            by two different threads, in rapid succession, in different orders can cause
            potentially unexpected results.
            </para>
            <para>
            In cases where the pair/tuple must be consistent at all times across all accesses,
            consider creating a struct containing the necessary fields/properties and wrapping
            that in a <see cref="T:Jcd.Tasks.SynchronizedValue`1"/> instead of each individual field/property.
            </para>
            <para>
            As well this implementation uses <see cref="T:System.Threading.SemaphoreSlim"/> and requires Dispose to be
            called. Either implement <see cref="T:System.IDisposable"/> or call it directly at the appropriate
            time. See the documentation for <see cref="M:Jcd.Tasks.SynchronizedValue`1.ChangeValue(System.Func{`0,`0})"/>, <see cref="M:Jcd.Tasks.SynchronizedValue`1.ChangeValueAsync(System.Func{`0,System.Threading.Tasks.Task{`0}})"/>, <see cref="M:Jcd.Tasks.SynchronizedValue`1.Do(System.Action{`0})"/>, and <see cref="M:Jcd.Tasks.SynchronizedValue`1.DoAsync(System.Func{`0,System.Threading.Tasks.Task})"/>
            for recursive reentrancy considerations. <i>(i.e. don't try it!)</i>
            </para>
            </remarks>
        </member>
        <member name="M:Jcd.Tasks.SynchronizedValue`1.#ctor(`0)">
            <summary>
            Provides a simple async-safe and thread-safe method of setting, getting, acting on,
            and altering values shared among tasks and threads.
            </summary>
            <param name="val">The value to initialize this to</param>
            <typeparam name="T">The data type to synchronize access to.</typeparam>
            <remarks>
            <para>
            While this provides a method of easily ensuring any one shared value is appropriately
            locked during setting or getting, you still need to thoroughly understand your
            use case. For example, having two <see cref="T:Jcd.Tasks.SynchronizedValue`1"/> instances accessed
            by two different threads, in rapid succession, in different orders can cause
            potentially unexpected results.
            </para>
            <para>
            In cases where the pair/tuple must be consistent at all times across all accesses,
            consider creating a struct containing the necessary fields/properties and wrapping
            that in a <see cref="T:Jcd.Tasks.SynchronizedValue`1"/> instead of each individual field/property.
            </para>
            <para>
            As well this implementation uses <see cref="T:System.Threading.SemaphoreSlim"/> and requires Dispose to be
            called. Either implement <see cref="T:System.IDisposable"/> or call it directly at the appropriate
            time. See the documentation for <see cref="M:Jcd.Tasks.SynchronizedValue`1.ChangeValue(System.Func{`0,`0})"/>, <see cref="M:Jcd.Tasks.SynchronizedValue`1.ChangeValueAsync(System.Func{`0,System.Threading.Tasks.Task{`0}})"/>, <see cref="M:Jcd.Tasks.SynchronizedValue`1.Do(System.Action{`0})"/>, and <see cref="M:Jcd.Tasks.SynchronizedValue`1.DoAsync(System.Func{`0,System.Threading.Tasks.Task})"/>
            for recursive reentrancy considerations. <i>(i.e. don't try it!)</i>
            </para>
            </remarks>
        </member>
        <member name="M:Jcd.Tasks.SynchronizedValue`1.Dispose">
            <inheritdoc />
        </member>
        <member name="P:Jcd.Tasks.SynchronizedValue`1.Value">
             <summary>
             Get or sets the synchronized value.
             </summary>
             <example>
             <code>
             var sv = new SynchronizedValue&lt;int&gt;(15);
             
             // get the value
             var theValue = sv.Value;
            
             // set the value
             sv.Value = theValue + 10;
             
             </code>
             </example>
        </member>
        <member name="M:Jcd.Tasks.SynchronizedValue`1.GetValue">
            <summary>
            Retrieves the current value. If another thread edits the value, moment later a subsequent
            call will yield a different result. 
            </summary>
            <returns>The current value as of establishing the lock.</returns>
            <example>
            <code>
            var sv = new SynchronizedValue&lt;int&gt;(15);
            
            // get the value
            setValue = sv.GetValue(20);
            
            </code>
            </example>
        </member>
        <member name="M:Jcd.Tasks.SynchronizedValue`1.GetValueAsync">
            <summary>
            Gets the value in an async friendly manner.
            </summary>
            <returns>A <see cref="T:System.Threading.Tasks.Task`1"/> containing the retrieved value.</returns>
            <example>
            <code>
            var sv = new SynchronizedValue&lt;int&gt;(15);
            
            // get the value
            await setValue = sv.GetValueAsync(20);
            
            </code>
            </example>
        </member>
        <member name="M:Jcd.Tasks.SynchronizedValue`1.SetValue(`0)">
            <summary>
            Sets the current value to the provided value.
            </summary>
            <param name="value">The provided value.</param>
            <returns>The provided value.</returns>
            <example>
            <code>
            var sv = new SynchronizedValue&lt;int&gt;();
            
            // set the value to 10.
            setValue = sv.SetValue(10);
            
            // set the value to 20.
            setValue = sv.SetValue(20);
            
            </code>
            </example>
        </member>
        <member name="M:Jcd.Tasks.SynchronizedValue`1.SetValueAsync(`0)">
            <summary>
            Sets the current value to the provided value.
            </summary>
            <param name="value">The provided value.</param>
            <returns>A <see cref="T:System.Threading.Tasks.Task`1"/> containing the provided value.</returns>
            <example>
            <code>
            var sv = new SynchronizedValue&lt;int&gt;();
            
            // set the value to 10.
            await setValue = sv.SetValueAsync(10);
            
            // set the value to 20.
            await setValue = sv.SetValueAsync(20);
            
            </code>
            </example>
        </member>
        <member name="M:Jcd.Tasks.SynchronizedValue`1.ChangeValue(System.Func{`0,`0})">
             <summary>
             Calls the provided function, passing in the current value, and assigns the result
             of the function call, to the current value. <b>This is not recursively reentrant.
             see remarks for details.</b>
             </summary>
             <param name="func">
             A function to call which receives the current value, modifies it, and returns the
             modified result.
             </param>
             <returns>The modified value.</returns>
             <example>
             Standard usage: pass in a function to manipulate the current value.
             <code>
             var sv = new SynchronizedValue&lt;int&gt;();
             
             // increment the value by one.
             var changedValue = sv.Do(x => x + 1);
             
             // increment the value by two.
             changedValue = sv.Do(x => x + 2);
             
             </code>
             </example>
             <remarks>
             <para>
             <b>WARNING:</b>This is <b>not</b> a recursively reentrant method. Never write code like
             the following.
             </para>
             <code>
             var sv=new SynchronizedValue&lt;int&gt;(10);
            
             // deadlock yourself in a single line of code!
             var changedValue = sv.Do(x=>sv.Value+10);
             </code>
             </remarks>
        </member>
        <member name="M:Jcd.Tasks.SynchronizedValue`1.ChangeValueAsync(System.Func{`0,System.Threading.Tasks.Task{`0}})">
             <summary>
             Calls the provided function, passing in the current value, and assigns the result
             of the function call, to the current value. <b>This is not recursively reentrant.
             see remarks for details.</b>
             </summary>
             <param name="func">The function to call.</param>
             <returns>A <see cref="T:System.Threading.Tasks.Task`1"/> containing the modified value.</returns>
             <example>
             Standard usage: pass in a function to manipulate the current value.
             <code>
             var sv = new SynchronizedValue&lt;int&gt;();
             
             // increment the value by one.
             var changedValue = await sv.ChangeValueAsync(x => x + 1);
             
             // increment the value by two.
             changedValue = await sv.ChangeValueAsync(x => x + 2);
             
             // Perform some operation that requires the value to remain unchanged during the operation.
             var sameValue = await sv.ChangeValueAsync(x => { DoSomething(x); return x;});
             </code>
             </example>
             <remarks>
             <para>
             <b>WARNING:</b>This is <b>not</b> a recursively reentrant method. Never write code like
             the following.
             </para>
             <code>
             var sv=new SynchronizedValue&lt;int&gt;(10);
            
             // deadlock yourself in a single line of code!
             var changedValue = await sv.ChangeValueAsync(x=>sv.Value+10);
             </code>
             </remarks>
        </member>
        <member name="M:Jcd.Tasks.SynchronizedValue`1.Do(System.Action{`0})">
             <summary>
             Executes an action on the synchronized value after locking it.
             <b>This is not recursively reentrant. See remarks for details.</b>
             </summary>
             <param name="action">The function to call.</param>
             <example>
             Standard usage: pass in an asynchronous action to action the current value.
             <code>
             var sv = new SynchronizedValue&lt;int&gt;();
             
             // increment the value by one and discard the result.
             sv.Do(x => x + 1);
             
             // increment the value by two and discard the result.
             sv.Do(x => x + 2);
             
             // Perform some other operation that requires the value to
             remain unchanged during the operation.
             sv.Do(x => DoSomething(x));
             </code>
             </example>
             <remarks>
             <para>
             <b>WARNING:</b>This is <b>not</b> a recursively reentrant method. Never write code like
             the following.
             </para>
             <code>
             var sv=new SynchronizedValue&lt;int&gt;(10);
            
             // deadlock yourself in a single line of code!
             sv.Do(x=>sv.Value+10);
             </code>
             </remarks>
        </member>
        <member name="M:Jcd.Tasks.SynchronizedValue`1.DoAsync(System.Func{`0,System.Threading.Tasks.Task})">
             <summary>
             Executes an asynchronous action on the synchronized value after locking it.
             <b>This is not recursively reentrant. See remarks for details.</b>
             </summary>
             <param name="asyncAction">The function to call.</param>
             <returns>A <see cref="T:System.Threading.Tasks.Task"/> for the action.</returns>
             <example>
             Standard usage: pass in an asynchronous action to action the current value.
             <code>
             var sv = new SynchronizedValue&lt;int&gt;();
             
             // increment the value by one and discard the result.
             var changedValue = await sv.DoAsync(x => x + 1);
             
             // increment the value by two and discard the result.
             await sv.DoAsync(x => x + 2);
             
             // Perform some other operation that requires the value to
             remain unchanged during the operation.
             await sv.DoAsync(x => DoSomething(x));
             </code>
             </example>
             <remarks>
             <para>
             <b>WARNING:</b>This is <b>not</b> a recursively reentrant method. Never write code like
             the following.
             </para>
             <code>
             var sv=new SynchronizedValue&lt;int&gt;(10);
            
             // deadlock yourself in a single line of code!
             await sv.DoAsync(x=>sv.Value+10);
             </code>
             </remarks>
        </member>
        <member name="T:Jcd.Tasks.TaskSchedulerExtensions">
            <summary>
            Adds various `Run` extension for any <see cref="T:System.Threading.Tasks.TaskScheduler"/> derived type.
            This allows tasks to be scheduled with the desired <see cref="T:System.Threading.Tasks.TaskScheduler"/>
            in a manner similar to `Task.Run` 
            </summary>
        </member>
        <member name="M:Jcd.Tasks.TaskSchedulerExtensions.Run(System.Threading.Tasks.TaskScheduler,System.Action)">
            <summary>
            Schedules work with the provided <see cref="T:System.Threading.Tasks.TaskScheduler"/>
            </summary>
            <param name="action">the action to execute.</param>
            <param name="scheduler">The scheduler to execute the action with.</param>
            <returns>The <see cref="T:System.Threading.Tasks.Task"/> representing the result of the execution.</returns>
        </member>
        <member name="M:Jcd.Tasks.TaskSchedulerExtensions.Run(System.Threading.Tasks.TaskScheduler,System.Action,System.Threading.CancellationToken)">
            <summary>
            Schedules work with the provided <see cref="T:System.Threading.Tasks.TaskScheduler"/>
            </summary>
            <param name="action">the action to execute.</param>
            <param name="scheduler">The scheduler to execute the action with.</param>
            <param name="cancellationToken">the token to check for cancellation</param>
            <returns>The <see cref="T:System.Threading.Tasks.Task"/> representing the result of the execution.</returns>
        </member>
        <member name="M:Jcd.Tasks.TaskSchedulerExtensions.Run(System.Threading.Tasks.TaskScheduler,System.Func{System.Threading.Tasks.Task})">
            <summary>
            Schedules work with the provided <see cref="T:System.Threading.Tasks.TaskScheduler"/>
            </summary>
            <param name="function">the function to execute.</param>
            <param name="scheduler">The scheduler to execute the function with.</param>
            <returns>The <see cref="T:System.Threading.Tasks.Task"/> representing the result of the execution.</returns>
        </member>
        <member name="M:Jcd.Tasks.TaskSchedulerExtensions.Run(System.Threading.Tasks.TaskScheduler,System.Func{System.Threading.Tasks.Task},System.Threading.CancellationToken)">
            <summary>
            Schedules work with the provided <see cref="T:System.Threading.Tasks.TaskScheduler"/>
            </summary>
            <param name="function">the action to execute.</param>
            <param name="scheduler">The scheduler to execute the function with.</param>
            <param name="cancellationToken">the token to check for cancellation</param>
            <returns>The <see cref="T:System.Threading.Tasks.Task"/> representing the result of the execution.</returns>
        </member>
        <member name="M:Jcd.Tasks.TaskSchedulerExtensions.Run``1(System.Threading.Tasks.TaskScheduler,System.Func{``0})">
            <summary>
            Schedules work with the provided <see cref="T:System.Threading.Tasks.TaskScheduler"/>
            </summary>
            <param name="function">the function to execute.</param>
            <param name="scheduler">The scheduler to execute the function with.</param>
            <returns>The <see cref="T:System.Threading.Tasks.Task"/> representing the result of the execution.</returns>
        </member>
        <member name="M:Jcd.Tasks.TaskSchedulerExtensions.Run``1(System.Threading.Tasks.TaskScheduler,System.Func{``0},System.Threading.CancellationToken)">
            <summary>
            Schedules work with the provided <see cref="T:System.Threading.Tasks.TaskScheduler"/>
            </summary>
            <param name="function">the function to execute.</param>
            <param name="scheduler">The scheduler to execute the function with.</param>
            <param name="cancellationToken">the token to check for cancellation</param>
            <returns>The <see cref="T:System.Threading.Tasks.Task"/> representing the result of the execution.</returns>
        </member>
        <member name="M:Jcd.Tasks.TaskSchedulerExtensions.Run``1(System.Threading.Tasks.TaskScheduler,System.Func{System.Threading.Tasks.Task{``0}})">
            <summary>
            Schedules work with the provided <see cref="T:System.Threading.Tasks.TaskScheduler"/>
            </summary>
            <param name="function">the function to execute.</param>
            <param name="scheduler">The scheduler to execute the function with.</param>
            <returns>The <see cref="T:System.Threading.Tasks.Task"/> representing the result of the execution.</returns>
        </member>
        <member name="M:Jcd.Tasks.TaskSchedulerExtensions.Run``1(System.Threading.Tasks.TaskScheduler,System.Func{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken)">
            <summary>
            Schedules work with the provided <see cref="T:System.Threading.Tasks.TaskScheduler"/>
            </summary>
            <param name="function">the function to execute.</param>
            <param name="scheduler">The scheduler to execute the function with.</param>
            <param name="cancellationToken">the token to check for cancellation</param>
            <returns>The <see cref="T:System.Threading.Tasks.Task"/> representing the result of the execution.</returns>
        </member>
    </members>
</doc>
